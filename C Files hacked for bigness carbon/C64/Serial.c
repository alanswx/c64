#include 	"Traps.h"//fix serial.h, remove byte and word declarations#include 	"Serial.h"#include	"Memory.h"#include	"Accessors.h"#include	"CPU.h"#include	"DebugWindow.h"#define	FLAGS				gCPUFlags#define	CYCLES				gCPUCycles#define	POPBYTE()			MEMREADBYTE(STACK+257);STACK=(unsigned char)STACK+1#define	POPWORD()			MEMREADWORD(STACK+257);STACK=(unsigned char)STACK+2#define	PUSHBYTE(x)			MEMWRITEBYTE((STACK+256),x);STACK=(unsigned char)STACK-1#define	PUSHWORD(x)			STACK=(unsigned char)STACK-1;MEMWRITEWORD((STACK+256),x);STACK=(unsigned char)STACK-1#define	BITN					0x80#define	BITV					0x40#define	BITB					0x10#define	BITD					0x08#define	BITI					0x04#define	BITZ					0x02#define	BITC					0x01#define	CLEARFLAGD()		FLAGS &= ~BITD#define	CLEARFLAGC()		FLAGS &= ~BITC#define	CLEARFLAGI()		FLAGS &= ~BITI#define	CLEARFLAGNZ()		FLAGS &= ~(BITN+BITZ)#define	CLEARFLAGNVZ()		FLAGS &= ~(BITN+BITV+BITZ)#define	CLEARFLAGNZC()		FLAGS	&= ~(BITN+BITZ+BITC)#define	CLEARFLAGNVZC()	FLAGS &= ~(BITN+BITV+BITZ+BITC)#define	SETFLAGN()			FLAGS |= BITN#define	SETFLAGI()			FLAGS |= BITI#define	SETFLAGZ()			FLAGS |= BITZ#define	SETFLAGC()			FLAGS |= BITC#define	SETFLAGV()			FLAGS |= BITV#define	TESTFLAGN()			(FLAGS & BITN)#define	TESTFLAGZ()			(FLAGS & BITZ)#define	TESTFLAGC()			(FLAGS & BITC)#define	TESTFLAGD()			(FLAGS & BITD)#define	TESTFLAGI()			(FLAGS & BITI)#define	TESTFLAGV()			(FLAGS & BITV)extern	unsigned	char	gCPUFlags;//#include "stack.h"/*	external globals	*/extern ReadHandler			*gMemRead;							//	Memory.cextern WriteHandler			*gMemWrite;							//	Memory.cextern void i60(void);//// %%%Al added this////#define	i60()	PopWord(pc); pc++;//#define	i60()	DebugStr("\pack, fix this");#define	i60()	CPUOP_60_RTS();#define	InternalError(a)	debug_window_printf("Internal Error");//unsigned	char	a;#define	a	gCPUAccumulatorextern	unsigned	char	gCPUAccumulator;typedef struct{    byte inuse  : 1;    byte isopen : 1;    byte (*getf)(byte *, int);    byte (*putf)(byte, int);    byte (*openf)(char *, int, int);    byte (*closef)(int);    void (*flushf)(int);} SerialType; SerialType device[16];#define BUFFERLEN 127static byte serialBuffer[BUFFERLEN];static byte serialPtr, latestListen, trapListen, latestSaListen;static void SerialSendByte(void), SerialRecieveByte(void), SerialListen(void),			SerialSaListen(void), FloppyReadyTrap(void);static byte SerialDummy(void);/*This is a table of 'traps' used to patch out the ROM to redirect allor the SerialIO and the FloppyReadyTrap to the MAC.AJS */static trap serialTrap[] ={	{ 0xed40, {0x78, 0x20, 0x97}, SerialSendByte },	{ 0xee13, {0x78, 0xa9, 0x00}, SerialRecieveByte },	{ 0xed0e, {0x20, 0xa4, 0xf0}, SerialListen },	{ 0xed36, {0x78, 0x20, 0x8e}, SerialSaListen },	{ 0xeea9, {0xad, 0x00, 0xdd}, FloppyReadyTrap }};/*This patches out the ROM and sets up the device structureCalled By:InitializeAJS*/int SerialInitialize(void){    byte i;	SerialType *p;	AddTrap(serialTrap[0]);	AddTrap(serialTrap[1]);	AddTrap(serialTrap[2]);	AddTrap(serialTrap[3]);	AddTrap(serialTrap[4]); 	/*The commodore can have 16 devices*/	/*setup the structure for each*/    for (i = 0; i < 16; i++) {		p=&device[i];		p->getf=(byte (*)(byte *, int ))SerialDummy;		p->putf=(byte (*)(byte, int ))SerialDummy;		p->openf=(byte (*)(char *, int , int ))SerialDummy;		p->closef=(byte (*)(int ))SerialDummy;		p->flushf=(void (*)(int ))NULL; }		return noErr;}/*This function adds the serial device to the structure and sets up all the function pointers,etc.Called By:FloppyInitializePrinterInitializeHardInitializeParameters:devnum	- this is the corresponding device # (ex: 8=floppy, etc.)¥Tie the functions to serial I/O for each device¥getf	-get a characterputf	-put a characteropenf	-open closef	-closeflushf	-flushAJS*/void AddSerialDevice(int devnum, byte (*getf)(byte *, int),	byte (*putf)(byte, int), byte (*openf)(char *, int, int),	byte (*closef)(int), void (*flushf)(int)){    SerialType *p;    if ((devnum<0)||(devnum>15))     	InternalError(kInvalidDeviceNumber);     p=&device[devnum];	if (p->inuse!=0) InternalError(kDeviceNumberInUse);	p->getf = getf;    p->putf = putf;    p->openf = openf;    p->closef = closef;    p->flushf = flushf;    p->inuse = 1;            }static void SerialSendByte(void){    byte data;    SerialType *p;    data=MEMREADBYTE(0x95);	#if	LOCALDEBUG && DEBUG	debug_window_printf("byte=%c",data);	#endif    p=&device[latestListen&0x0f];    if (p->isopen==0)     	{		if (serialPtr<BUFFERLEN) 			serialBuffer[serialPtr++] = data; 		}    else     	(*p->putf)(data, latestSaListen & 0x0f);	i60();	/* RTS */}static void SerialRecieveByte(void){    byte 			pp;    SerialType 		*p;	byte			edsucks;	    p=&device[latestListen&0x0f];	edsucks=((*p->getf)(&pp, latestSaListen&0x0f)) & 0xFF;   	MEMWRITEBYTE(0x90,edsucks);		a=pp;	MEMWRITEBYTE(0xa4,a);////%%% fix this!////	FLAGS &= ~CAR;CLEARFLAGC();	i60();	/* RTS */}static void SerialListen(void){//	debug_window_printf("listen");	trapListen=a;	i60();	/* RTS */}//////static void SerialSaListen(void){	SerialType *p;	byte b, i;//	debug_window_printf("salisten");    b=MEMREADBYTE(0x95);    p=&device[latestListen&0x0f];	if (b==0x3f)		switch (latestSaListen&0xf0) {			case 0xf0:	 			if (p->isopen==0) 	 				{					p->isopen=1;					i=(*p->openf)((char *)serialBuffer, serialPtr, latestSaListen&0x0f);					serialPtr=0;					MEMWRITEBYTE(0x90,i);					if (i) 						{						p->isopen=0;						(*p->closef)(latestSaListen&0x0f); 						} 					}	    		if (p->flushf) 	    			(*p->flushf)(latestSaListen&0x0f);				break;			case 0x60:				if (p->isopen==0) 					{					p->isopen=1;					(*p->openf)(NULL, 0, latestSaListen&0x0f);					for (i=0; i<serialPtr; i++)						(*p->putf)(serialBuffer[i], latestSaListen&0x0f);					serialPtr=0; 					}				if (p->flushf) 					(*p->flushf)(latestSaListen&0x0f);				break;			case 0xe0:				p->isopen=0;				(*p->closef)(latestSaListen&0x0f);				break;			default:				debug_window_printf("Unimplemented Serial Command"); break;			}	latestListen=trapListen;	latestSaListen=b;	i60();	/* RTS */}static void FloppyReadyTrap(void){//    extern void i60(void);		a = 0x01;//debug_window_printf("floppyready");//%%% fix this//	flags &=(~NEG+ZER);CLEARFLAGNZ();SETFLAGZ();	i60();	/* RTS */}static byte SerialDummy(void) { return 2; }