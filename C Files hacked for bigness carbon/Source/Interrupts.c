/*-------------------------------------------------------------------------------*\||	File:	Interrupts.c||	Description:||||||	Copyright ï¿½	1994, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include <stdio.h>#include "DebugWindow.h"#include "Debug.h"#include	"VICInterrupts.h"#include "Accessors.h"#include "Memory.h"#include "CIA1.h"#include "CIA2.h"#include "CPU.h"#include "Combug.h"#include "Interrupts.h"#if	DEBUGextern	Boolean	gVerbose;#endif#define	LOCALDEBUG			0/*	local constants	*/#define	kIRQVector				0xFFFE#define	kNMIVector				0xFFFA#define	kRasterTimerValue		67#define	kCPUTimerValue			1000000//#define	kCPUThrottleValue		8333*2	//throttle to 1.0 or use 1000000#define	kCPUThrottleValue		1000000	//throttle to 1.0 or use 1000000#define	kWNETimerCounter		100000/*	extern globals	*/extern unsigned long			gSTACKRegister;extern unsigned long			gPCRegister;extern unsigned long			gSRRegister;extern unsigned long			gTraceMode;extern unsigned char			gVICInterruptRequestLine;extern long 					gStartTicks;extern CombugState			gCombugState;		// Combug.cextern unsigned char			*gRAMBlock;							//	Memory.cextern ReadHandler			*gMemRead;							//	Memory.cextern WriteHandler			*gMemWrite;							//	Memory.c/*	local globals	*/long		gInterruptFlag = 0;long		gInterruptCounter = 0;long		gCPUTimerCounter = 0;long		gCPUThrottleCounter = 0;long		gCPULastThrottle = 0;long		gWNETimerCounter = 0;long		gRasterInterruptCounter = 0;long		gCIA1TimerACounter = 0x80000000;long		gCIA2TimerACounter = 0x80000000;unsigned long InterruptCheck(void){	register unsigned long	least,result = 0;	register long				elapsed;    fprintf(stderr,"InterruptCheck\n");		elapsed = gInterruptCounter - gInterruptFlag;    fprintf(stderr,"InterruptCheck %ld\n",elapsed);    fprintf(stderr,"tickcount: %d\n",TickCount());	gInterruptFlag = gInterruptCounter;		gRasterInterruptCounter -= elapsed;	gCPUTimerCounter -= elapsed;	gCPUThrottleCounter -= elapsed;	gWNETimerCounter -= elapsed;			if (gRasterInterruptCounter <= 0)	{		VICRasterIncrement();		gRasterInterruptCounter = kRasterTimerValue;	}		if (gCPUTimerCounter <= 0)	{		gCPUTimerCounter = kCPUTimerValue;		gStartTicks = TickCount() - gStartTicks;				UpdateSpeedWindow((float)(((60.0)/(1000000.0/kCPUTimerValue)/((float)gStartTicks))));		gStartTicks = TickCount();	}		if (gCPUThrottleCounter <= 0)	{		if (gCPULastThrottle == TickCount())			gWNETimerCounter = 0;		else		{			gCPULastThrottle = TickCount();			gCPUThrottleCounter = kCPUThrottleValue;		}	}		if (gWNETimerCounter <= 0)	{		gWNETimerCounter = kWNETimerCounter;		result = 1;	}	    fprintf(stderr,"gCIA1TimerACounter= %lx\n",gCIA1TimerACounter);	if (gCIA1TimerACounter != 0x80000000)	{        fprintf(stderr,"gCIA1TimerACounter!= 0x80000000\n");		gCIA1TimerACounter -= elapsed;		if (gCIA1TimerACounter < 0)		{			gCIA1TimerACounter = 0x80000000;			CIA1TimerAExpire();		}	}			if (gCIA2TimerACounter != 0x80000000)	{        fprintf(stderr,"gCIA2TimerACounter!= 0x80000000\n");		gCIA2TimerACounter -= elapsed;		if (gCIA2TimerACounter < 0)		{			gCIA2TimerACounter = 0x80000000;			CIA2TimerAExpire();		}	}			least = 0xFFFFFFFF;	if (gRasterInterruptCounter < least)		least = gRasterInterruptCounter;	if (gCPUTimerCounter < least)		least = gCPUTimerCounter;	if ((gCIA1TimerACounter != 0x80000000) && (gCIA1TimerACounter < least))		least = gCIA1TimerACounter;	if ((gCIA2TimerACounter != 0x80000000) && (gCIA2TimerACounter < least))		least = gCIA2TimerACounter;		gInterruptCounter = gInterruptFlag = least;		if (gTraceMode)	{		gInterruptCounter = gInterruptFlag = 0;		return 1;	}		return result;}void CalculateNextInterrupt(void){	register unsigned long	least;	register long				elapsed;        fprintf(stderr,"CalculateNextInterrupt\n");		elapsed = gInterruptCounter - gInterruptFlag;    fprintf(stderr,"CalculateNextInterrupt elapsed: %ld\n",elapsed);    	gRasterInterruptCounter -= elapsed;	gCPUTimerCounter -= elapsed;	gWNETimerCounter -= elapsed;	gCPUThrottleCounter -= elapsed;		if (gCIA1TimerACounter != 0x80000000)		gCIA1TimerACounter -= elapsed;		if (gCIA2TimerACounter != 0x80000000)		gCIA2TimerACounter -= elapsed;		least = 0xFFFFFFFF;	if (gRasterInterruptCounter < least)		least = gRasterInterruptCounter;	if (gCPUTimerCounter < least)		least = gCPUTimerCounter;	if (gCPUThrottleCounter < least)		least = gCPUThrottleCounter;	if (gWNETimerCounter < least)		least = gWNETimerCounter;		if ((gCIA1TimerACounter != 0x80000000) && (gCIA1TimerACounter < least))		least = gCIA1TimerACounter;	if ((gCIA2TimerACounter != 0x80000000) && (gCIA2TimerACounter < least))		least = gCIA2TimerACounter;		if (gTraceMode)		gInterruptCounter = gInterruptFlag = 0;	else		gInterruptCounter = gInterruptFlag = least;}short IRQInterrupt(void){    fprintf(stderr,"IRQInterrupt\n");	//	block if interrupts disabled	if (gSRRegister&0x04)		return 0;			//	push the PC onto the stack	gSTACKRegister =(unsigned char)(gSTACKRegister-1);	MEMWRITEWORD((gSTACKRegister+256),gPCRegister);	gSTACKRegister =(unsigned char)gSTACKRegister-1;		//	push the SR onto the stack	MEMWRITEBYTE((gSTACKRegister+256),gSRRegister);	gSTACKRegister =(unsigned char)gSTACKRegister-1;		//	disable interrupts & load new PC	gSRRegister |= 0x04;	gPCRegister = MEMREADWORD(kIRQVector);	//	gTraceMode = 1;//	gCombugState.halted = 1;//	CalculateNextInterrupt();/*	{		long	temp;		char	wah[40];				temp = (long)&gRAMBlock[0];		temp += (gSTACKRegister+0x101);		sprintf(wah,"New Interrupt:;dm %lX",temp);		CtoPstr(wah);		DebugStr((StringPtr)wah);	}*/			return 1;}short NMIInterrupt(void){    fprintf(stderr,"NMIInterrupt\n");	//	push the PC onto the stack	gSTACKRegister =(unsigned char)(gSTACKRegister-1);	MEMWRITEWORD((gSTACKRegister+256),gPCRegister);	gSTACKRegister =(unsigned char)gSTACKRegister-1;		//	push the SR onto the stack	MEMWRITEBYTE((gSTACKRegister+256),gSRRegister);	gSTACKRegister =(unsigned char)gSTACKRegister-1;		//	disable interrupts & load new PC	gSRRegister |= 0x04;	gPCRegister = MEMREADWORD(kNMIVector);	//	gTraceMode = 1;//	gCombugState.halted = 1;//	CalculateNextInterrupt();/*	{		long	temp;		char	wah[40];				temp = (long)&gRAMBlock[0];		temp += (gSTACKRegister+0x101);		sprintf(wah,"New Interrupt:;dm %lX",temp);		CtoPstr(wah);		DebugStr((StringPtr)wah);	}*/			return 1;}void CheckForLatchedInterrupts(void){	#if	LOCALDEBUG && DEBUG	if (gVerbose)		debug_window_printf("We are in CheckForLatchedInterrupts");	#endif			if (CIA1InterruptPending())		{		IRQInterrupt();		}	else if (gVICInterruptRequestLine)	{		IRQInterrupt();		gVICInterruptRequestLine = 0;	}}void SetCPUTimingInterruptCounter(long count){	gCPUTimerCounter = count;	CalculateNextInterrupt();}void SetRasterLineInterruptCounter(long count){	gRasterInterruptCounter = count;	CalculateNextInterrupt();}void SetCIA1TimerAInterruptCounter(long count){    fprintf(stderr,"SetCIA1TimerAInterruptCounter %ld\n",count);	gCIA1TimerACounter = count;	CalculateNextInterrupt();}void SetCIA2TimerAInterruptCounter(long count){	gCIA2TimerACounter = count;	CalculateNextInterrupt();}