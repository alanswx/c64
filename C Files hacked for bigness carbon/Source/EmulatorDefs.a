;; IMPORT and EXPORT declarations;		EXPORT		ASMCPU:CODE				IMPORT		READTable:CODE		IMPORT		WRITETable:CODE		IMPORT		InterruptCheck:CODE		IMPORT		CheckForLatchedInterrupts:CODE		IMPORT		PageZeroWrite:CODE		IMPORT		gACCRegister:DATA		IMPORT		gINXRegister:DATA		IMPORT		gINYRegister:DATA		IMPORT		gSTACKRegister:DATA		IMPORT		gPCRegister:DATA		IMPORT		gSRRegister:DATA		IMPORT		gInterruptFlag:DATA		IMPORT		gRAMBlock:DATA		IMPORT		gMemRead:DATA		IMPORT		gMemWrite:DATA;; Definitions and declarations;ALIGNSHIFT			EQU			$07INSTRALIGN			EQU			(1<<ALIGNSHIFT)INTERRUPT_FLAG		EQU			gInterruptFlagPREFETCH_DATA		EQU			D3INX					EQU			D4INY					EQU			D5ACC					EQU			D6SR_STACK			EQU			D7PRGCNTR				EQU			A4BITC				EQU			$01BITV				EQU			$02BITZ				EQU			$04BITN				EQU			$08BITB				EQU			$20BITD				EQU			$40BITI				EQU			$80POSC				EQU			$00POSV				EQU			$01POSZ				EQU			$02POSN				EQU			$03POSD				EQU			$06;; Macro definitions;	MACRO		PREFETCH										; stomps D0 and D1				MOVE.L		PRGCNTR,D1							; get our play copy		MOVEQ		#12,D0								; setup for nybble shift		LSR.W		D0,D1								; shift high nybble into low nybble		MOVE.L		(READTable,D1.L*4),D1				; magically get base address into D1		MOVE.L		(PRGCNTR,D1.L),PREFETCH_DATA		; fetch long word		ROL.L		#$08,PREFETCH_DATA					; rotate high byte into low byte		ENDM						MACRO		DISPATCH										; assumes high 3 bytes of D0 are zero				MOVE.B		PREFETCH_DATA,D0					; get opcode to dispatch		LSL.W		#ALIGNSHIFT,D0						; multiply by table size		JMP			(OPTABLEBASE,D0.W)					; jmp to opcode handler		ENDM				MACRO		FINISH		&cycles								; stomps all volatile registers				SUBQ.L		#&cycles,INTERRUPT_FLAG(A5)			; update interrupt/cycle counter		BMI.S		@1									; do we need to check for pending interrupt?		PREFETCH										; prefetch next instruction		DISPATCH										; dispatch to next instruction@1		BRA.W		DOINTERRUPTCHECK					; handle pending interrupt		ENDM						MACRO		MSETNZ											; stomps D0 (assumes CCs were set via MOVE)				MOVE.W		CCR,D0								; fetch condition codes		ANDI.B		#$FF-BITN-BITZ,SR_STACK				; clear stale condition codes		OR.B		D0,SR_STACK							; set condition codes		ENDM					MACRO		ASETNZC											; stomps D0 (assumes CCs were set via ADD/SUB)				MOVE.W		CCR,D0								; fetch condition codes		ANDI.B		#$FF-BITN-BITZ-BITC,SR_STACK		; clear stale condition codes		ANDI.B		#BITN+BITZ+BITC,D0					; mask wanted condition codes		EORI.B		#BITC,D0							; invert carry for 65xx weirdness		OR.B		D0,SR_STACK							; set condition codes		ENDM						MACRO		ASETNZ											; stomps D0 (assumes CCs were set via ADD/SUB)				MOVE.W		CCR,D0								; fetch condition codes		ANDI.B		#$FF-BITN-BITZ,SR_STACK				; clear stale condition codes		ANDI.B		#BITN+BITZ,D0						; mask wanted condition codes		OR.B		D0,SR_STACK							; set condition codes		ENDM						MACRO		INCPC		&bytes								; safe				ADDQ.W		#&bytes,PRGCNTR						; add to program counter		ENDM					;; Addressing mode macro definitions;	MACRO		LOAD_IMM										; loads into PREFETCH_DATA not DO!				ROL.L		#$08,PREFETCH_DATA					; get immediate data byte		ENDM						MACRO		LOAD_ABS										; stomps all volatile registers				CLR.W		PREFETCH_DATA						; zero (soon to be) high word of prefetch data		SWAP		PREFETCH_DATA						; get absolute data word		ROL.W		#$08,PREFETCH_DATA					; swap byte ordering for big endies		MOVE.L		PREFETCH_DATA,D1					; get our play copy		MOVEQ		#12,D0								; setup for nybble shift		LSR.W		D0,D1								; shift high nybble into low nybble		MOVE.L		(READTable,D1.L*4),D1				; magically get base address into D1		BEQ.S		@DOVECTORREAD						; handle vectored read		MOVEA.L		D1,A0								; move base address into address register		MOVE.B		(A0,PREFETCH_DATA.L),D0				; fetch byte		BRA.S		@2@DOVECTORREAD		MOVEA.L		PREFETCH_DATA,A0					; load address for memory accessor		LSR.W		#$08,PREFETCH_DATA					; compute address page		MOVEA.L		gMemRead,A1							; load vector table base		JSR			([$00,A1,PREFETCH_DATA.L*$04])		; fetch byte from memory via vector@2		ENDM						MACRO		LOAD_ABSX										; stomps all volatile registers				CLR.W		PREFETCH_DATA						; zero (soon to be) high word of prefetch data		SWAP		PREFETCH_DATA						; get absolute data word		ROL.W		#$08,PREFETCH_DATA					; swap byte ordering for big endies		ADD.W		INX,PREFETCH_DATA					; add Index X register displacement		MOVE.L		PREFETCH_DATA,D1					; get our play copy		MOVEQ		#12,D0								; setup for nybble shift		LSR.W		D0,D1								; shift high nybble into low nybble		MOVE.L		(READTable,D1.L*4),D1				; magically get base address into D1		BEQ.S		@DOVECTORREAD						; handle vectored read		MOVEA.L		D1,A0								; move base address into address register		MOVE.B		(A0,PREFETCH_DATA.L),D0				; fetch byte		BRA.S		@2@DOVECTORREAD		MOVEA.L		PREFETCH_DATA,A0					; load address for memory accessor		LSR.W		#$08,PREFETCH_DATA					; compute address page		MOVEA.L		gMemRead,A1							; load vector table base		JSR			([$00,A1,PREFETCH_DATA.L*$04])		; fetch byte from memory via vector@2		ENDM	MACRO		LOAD_ABSY										; stomps all volatile registers				CLR.W		PREFETCH_DATA						; zero (soon to be) high word of prefetch data		SWAP		PREFETCH_DATA						; get absolute data word		ROL.W		#$08,PREFETCH_DATA					; swap byte ordering for big endies		ADD.W		INY,PREFETCH_DATA					; add Index Y register displacement		MOVE.L		PREFETCH_DATA,D1					; get our play copy		MOVEQ		#12,D0								; setup for nybble shift		LSR.W		D0,D1								; shift high nybble into low nybble		MOVE.L		(READTable,D1.L*4),D1				; magically get base address into D1		BEQ.S		@DOVECTORREAD						; handle vectored read		MOVEA.L		D1,A0								; move base address into address register		MOVE.B		(A0,PREFETCH_DATA.L),D0				; fetch byte		BRA.S		@2@DOVECTORREAD		MOVEA.L		PREFETCH_DATA,A0					; load address for memory accessor		LSR.W		#$08,PREFETCH_DATA					; compute address page		MOVEA.L		gMemRead,A1							; load vector table base		JSR			([$00,A1,PREFETCH_DATA.L*$04])		; fetch byte from memory via vector@2		ENDM	MACRO		STORE_ABS	&value_reg							; stomps all volatile registers (value can't be D0 or D1)				CLR.W		PREFETCH_DATA						; zero (soon to be) high word of prefetch data		SWAP		PREFETCH_DATA						; get absolute data word		ROL.W		#$08,PREFETCH_DATA					; swap byte ordering for big endies		MOVE.L		PREFETCH_DATA,D1					; get our play copy		LSR.W		#1,D1								; check for 0 or 1		BEQ.S		@DOZPVECTORWRITE					; handle 0 or 1 case		MOVEQ		#11,D0								; setup for nybble shift		LSR.W		D0,D1								; shift high nybble into low nybble		MOVE.L		(WRITETable,D1.L*4),D1				; magically get base address into D1		BEQ.S		@DOVECTORWRITE						; handle vectored read		MOVEA.L		D1,A0								; move base address into address register		MOVE.B		&value_reg,(A0,PREFETCH_DATA.L)		; store byte		BRA.S		@4@DOZPVECTORWRITE		MOVE.L		&value_reg,-(SP)					; push argument: value		MOVE.L		PREFETCH_DATA,-(SP)					; push argument: address		PEA			@3									; push return address		JMP			PageZeroWrite						; store byte to memory via vector@DOVECTORWRITE		MOVE.L		&value_reg,-(SP)					; push argument: value		MOVE.L		PREFETCH_DATA,-(SP)					; push argument: address		LSR.W		#$08,PREFETCH_DATA					; compute address page		MOVEA.L		gMemWrite,A1						; load vector table base		JSR			([$00,A1,PREFETCH_DATA.L*$04])		; fetch byte from memory via vector@3		ADDQ.W		#$08,SP								; clean up the stack@4		ENDM	MACRO		STORE_ABSX	&value_reg							; stomps all volatile registers (value can't be D0 or D1)				CLR.W		PREFETCH_DATA						; zero (soon to be) high word of prefetch data		SWAP		PREFETCH_DATA						; get absolute data word		ROL.W		#$08,PREFETCH_DATA					; swap byte ordering for big endies		ADD.W		INX,PREFETCH_DATA					; add Index X register displacement		MOVE.L		PREFETCH_DATA,D1					; get our play copy		LSR.W		#1,D1								; check for 0 or 1		BEQ.S		@DOZPVECTORWRITE					; handle 0 or 1 case		MOVEQ		#11,D0								; setup for nybble shift		LSR.W		D0,D1								; shift high nybble into low nybble		MOVE.L		(WRITETable,D1.L*4),D1				; magically get base address into D1		BEQ.S		@DOVECTORWRITE						; handle vectored read		MOVEA.L		D1,A0								; move base address into address register		MOVE.B		&value_reg,(A0,PREFETCH_DATA.L)		; store byte		BRA.S		@4@DOZPVECTORWRITE		MOVE.L		&value_reg,-(SP)					; push argument: value		MOVE.L		PREFETCH_DATA,-(SP)					; push argument: address		PEA			@3									; push return address		JMP			PageZeroWrite						; store byte to memory via vector@DOVECTORWRITE		MOVE.L		&value_reg,-(SP)					; push argument: value		MOVE.L		PREFETCH_DATA,-(SP)					; push argument: address		LSR.W		#$08,PREFETCH_DATA					; compute address page		MOVEA.L		gMemWrite,A1						; load vector table base		JSR			([$00,A1,PREFETCH_DATA.L*$04])		; fetch byte from memory via vector@3		ADDQ.W		#$08,SP								; clean up the stack@4		ENDM	MACRO		STORE_ABSY	&value_reg							; stomps all volatile registers (value can't be D0 or D1)				CLR.W		PREFETCH_DATA						; zero (soon to be) high word of prefetch data		SWAP		PREFETCH_DATA						; get absolute data word		ROL.W		#$08,PREFETCH_DATA					; swap byte ordering for big endies		ADD.W		INY,PREFETCH_DATA					; add Index X register displacement		MOVE.L		PREFETCH_DATA,D1					; get our play copy		LSR.W		#1,D1								; check for 0 or 1		BEQ.S		@DOZPVECTORWRITE					; handle 0 or 1 case		MOVEQ		#11,D0								; setup for nybble shift		LSR.W		D0,D1								; shift high nybble into low nybble		MOVE.L		(WRITETable,D1.L*4),D1				; magically get base address into D1		BEQ.S		@DOVECTORWRITE						; handle vectored read		MOVEA.L		D1,A0								; move base address into address register		MOVE.B		&value_reg,(A0,PREFETCH_DATA.L)		; store byte		BRA.S		@4@DOZPVECTORWRITE		MOVE.L		&value_reg,-(SP)					; push argument: value		MOVE.L		PREFETCH_DATA,-(SP)					; push argument: address		PEA			@3									; push return address		JMP			PageZeroWrite						; store byte to memory via vector@DOVECTORWRITE		MOVE.L		&value_reg,-(SP)					; push argument: value		MOVE.L		PREFETCH_DATA,-(SP)					; push argument: address		LSR.W		#$08,PREFETCH_DATA					; compute address page		MOVEA.L		gMemWrite,A1						; load vector table base		JSR			([$00,A1,PREFETCH_DATA.L*$04])		; fetch byte from memory via vector@3		ADDQ.W		#$08,SP								; clean up the stack@4		ENDM	MACRO		STORE_ZP	&value_reg							; stomps all volatile registers (value can't be D0 or D1)				CLR.W		PREFETCH_DATA						; zero (soon to be) high word of prefetch data		ROL.L		#$08,PREFETCH_DATA					; get Zero Page address		EXT.L		PREFETCH_DATA						; clear high byte of address		MOVE.L		PREFETCH_DATA,D1					; get our play copy		LSR.W		#1,D1								; check for 0 or 1		BEQ.S		@DOZPVECTORWRITE					; handle 0 or 1 case		MOVEQ		#11,D0								; setup for nybble shift		LSR.W		D0,D1								; shift high nybble into low nybble		MOVE.L		(WRITETable,D1.L*4),D1				; magically get base address into D1		BEQ.S		@DOVECTORWRITE						; handle vectored read		MOVEA.L		D1,A0								; move base address into address register		MOVE.B		&value_reg,(A0,PREFETCH_DATA.L)		; store byte		BRA.S		@4@DOZPVECTORWRITE		MOVE.L		&value_reg,-(SP)					; push argument: value		MOVE.L		PREFETCH_DATA,-(SP)					; push argument: address		PEA			@3									; push return address		JMP			PageZeroWrite						; store byte to memory via vector@DOVECTORWRITE		MOVE.L		&value_reg,-(SP)					; push argument: value		MOVE.L		PREFETCH_DATA,-(SP)					; push argument: address		LSR.W		#$08,PREFETCH_DATA					; compute address page		MOVEA.L		gMemWrite,A1						; load vector table base		JSR			([$00,A1,PREFETCH_DATA.L*$04])		; fetch byte from memory via vector@3		ADDQ.W		#$08,SP								; clean up the stack@4		ENDM;; Instruction macro definitions;	MACRO		ANDACC		&data_reg							; stomps D0				AND.B		&data_reg,ACC						; AND byte with Accumulator register		MSETNZ											; set condition codes		ENDM						MACRO		COMPARE		&target								; stomps D0 and D1 (assumes D0 is compare byte)				MOVE.L		&target,D1							; get copy of target register		SUB.B		D0,D1								; compare by subtraction		ASETNZC											; set condition codes		ENDM	MACRO		LOADACC		&source								; stomps D0				MOVE.B		&source,ACC							; load Accumulator register		MSETNZ											; set condition codes		ENDM	MACRO		LOADINX		&source								; stomps D0				MOVE.B		&source,INX							; load Index X register		MSETNZ											; set condition codes		ENDM	MACRO		LOADINY		&source								; stomps D0				MOVE.B		&source,INY							; load Index Y register		MSETNZ											; set condition codes		ENDM	MACRO		ORACC		&data_reg							; stomps D0				OR.B		&data_reg,ACC						; OR byte with Accumulator register		MSETNZ											; set condition codes		ENDM