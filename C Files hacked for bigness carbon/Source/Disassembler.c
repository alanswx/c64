/*-------------------------------------------------------------------------------*\||	File:	Disassembler.c||	Description:||||||	Copyright ©	1994, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include <stdio.h>#include <string.h>#include "DebugWindow.h"#include "Accessors.h"#include "Memory.h"#include "Disassembler.h"/*	external globals	*/extern ReadHandler	*gMemRead;			//	Memory.cextern WriteHandler	*gMemWrite;			//	Memory.cshort DisassembleOPCode(unsigned long pc,char *output){	unsigned long	op,data;	unsigned short	temp;	char	cdata;	short	len = 0;			op = MEMREADBYTE(pc);pc++;	switch(op)	{		case 0x01:	//	ORA	A <- A | M				2/6 zero page indexed indirect, X			sprintf(output,"ORA %2lX,X^",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x05:	//	ORA	A <- A | M				2/3 zero page			sprintf(output,"ORA %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x06:	//	ASL	C <- M7, M <- M << 1	2/5 zero page			sprintf(output,"ASL %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x08:	//	PHP	STACK <- A				1/3 implied			sprintf(output,"PHP");len=1;			break;		case 0x09:	//	ORA	A <- A | M				2/2 immediate			sprintf(output,"ORA #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x0A:	//	ASL	C <- A7, A <- (A) << 1	1/2 accumulator			sprintf(output,"ASL");len=1;			break;		case 0x0D:	//	ORA	A <- M					3/4 absolute			sprintf(output,"ORA %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x0E:	//	ASL	C <- M7, M <- M << 1	3/4 absolute			sprintf(output,"ASL %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x10:	//	BPL	if N=0, PC = PC + offset	2/2 relative			cdata = MEMREADBYTE(pc);			temp = 1+pc+cdata;			sprintf(output,"BPL *%c%02lX     ; %04X",(cdata<0)?'-':'+',(long int)((cdata<0)?(-cdata):cdata),temp);			len=2;			break;		case 0x11:	//	ORA	A <- A | M				2/5 zero page indirect indexed, Y			sprintf(output,"ORA %2lX^,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x15:	//	ORA	A <- M					2/4 zero page indexed, X			sprintf(output,"ORA %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x16:	//	ASL	C <- M7, M <- M << 1	2/6 zero page indexed, X			sprintf(output,"ASL %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x18:	//	CLC	C <- 0					1/2 implied			sprintf(output,"CLC");len=1;			break;		case 0x19:	//	ORA		A <- M				3/4 absolute indexed, Y			sprintf(output,"ORA %4lX,Y",(long int)MEMREADWORD(pc));len=3;			break;		case 0x1D:	// ORA		A <- M				3/4 absolute indexed, X			sprintf(output,"ORA %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0x1E:	// ASL	C <- M7, M <- M << 1	3/7 absolute indexed, X			sprintf(output,"ASL %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0x20:	//	JSR	Stack <- PC, PC <- Address		3/6 absolute			sprintf(output,"JSR %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x21:	//	AND	A <- A & M				2/6 zero page indexed indirect, X			sprintf(output,"AND #%2lX,X^",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x24:	//	Z <- ~(A /\ M) N<-M7 V<-M6		2/3 zero page			sprintf(output,"BIT %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x25:	//	AND	A <- A & M				2/3 zero page			sprintf(output,"AND #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x26:	//	ROL	C <- A7, A <- A << 1 + C	2/5 zero page			sprintf(output,"ROL %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x28:	//	Flags <- (Stack)				1/4 implied			sprintf(output,"PLP");len=1;			break;		case 0x29:	//	AND	A <- A & M				2/2 immediate			sprintf(output,"AND #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x2A:	//	ROL	C <- A7, A <- A << 1 + C	1/2 accumulator			sprintf(output,"ROL");len=1;			break;		case 0x2C:	//	Z <- ~(A /\ M) N<-M7 V<-M6		3/4 absolute			sprintf(output,"BIT %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x2D:	//	AND	A <- A & M				3/4 absolute			sprintf(output,"AND #%4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x2E:	//	ROL	C <- A7, A <- A << 1 + C	3/6 absolute			sprintf(output,"ROL %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x30:	//	BMI	if N=1, PC = PC + offset	2/2 relative			cdata = MEMREADBYTE(pc);			temp = 1+pc+cdata;			sprintf(output,"BMI *%c%02lX     ; %04X",(cdata<0)?'-':'+',(long int)((cdata<0)?(-cdata):cdata),temp);			len=2;			break;		case 0x31:	//	AND	A <- A & M				2/5 zero page indirect indexed, Y			sprintf(output,"AND %2lX^,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x35:	//	AND	A <- A & M				2/4 zero page indexed, X			sprintf(output,"AND %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x36:	//	ROL	C <- A7, A <- A << 1 + C	2/6 zero page indexed, X			sprintf(output,"ROL %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x38:	//	C <- 1							1/2 implied			sprintf(output,"SEC");len=1;			break;		case 0x39:	//	AND	A <- A & M			3/4 absolute indexed, Y			sprintf(output,"AND %4lX,Y",(long int)MEMREADWORD(pc));len=3;			break;		case 0x3D:	//	AND	A <- A & M			3/4 absolute indexed, X			sprintf(output,"AND %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0x3E:	//	ROL	C <- A7, A <- A << 1 + C	3/7 absolute indexed, X			sprintf(output,"ROL %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0x40:	//	P <- (Stack), PC <-(Stack)	1/6 implied			sprintf(output,"RTI");len=1;			break;		case 0x41:	//	A <- A XOR M					2/6 zero page indirect indexed, Y			sprintf(output,"EOR %2lX^,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x45:	//	A <- A XOR M					2/3 zero page			sprintf(output,"EOR %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x46:	// C <- A0, A <- A >> 1			3/7 absolute indexed, X			sprintf(output,"LSR %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0x48:	//	Stack <- A						1/3 implied			sprintf(output,"PHA");len=1;			break;		case 0x49:	//	A <- A XOR M					2/2 immediate			sprintf(output,"EOR %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x4A:	// C <- A0, A <- A >> 1			1/2 accumulator			sprintf(output,"LSR");len=1;			break;		case 0x4C:	//	JMP	PC <- Address			3/3 absolute			sprintf(output,"JMP %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x4D:	//	A <- A XOR M					3/4 absolute			sprintf(output,"EOR %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x4E:	// C <- A0, A <- A >> 1			3/6 absolute			sprintf(output,"LSR %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x50:	//	BVC	if V=1, PC = PC + offset	2/2 relative			cdata = MEMREADBYTE(pc);			temp = 1+pc+cdata;			sprintf(output,"BVC *%c%02lX     ; %04X",(cdata<0)?'-':'+',(long int)((cdata<0)?(-cdata):cdata),temp);			len=2;			break;		case 0x51:	//	A <- A XOR M					2/6 zero page indirect indexed, X			sprintf(output,"EOR %2lX^,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x55:	//	A <- A XOR M					2/4 zero page indexed, X			sprintf(output,"EOR %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x56:	// C <- A0, A <- A >> 1			2/6 zero page indexed, X			sprintf(output,"LSR %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x58:	//	I <- 0							1/2 implied			sprintf(output,"CLI");len=1;			break;		case 0x59:	//	A <- A XOR M					2/4 zero page indexed, Y			sprintf(output,"EOR %2lX,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x5D:	//	A <- A XOR M					3/4 absolute indexed, X			sprintf(output,"EOR %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0x5E:	// C <- A0, A <- A >> 1			3/7 absolute indexed, X			sprintf(output,"LSR %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0x60:	//	RTS	PC <- (Stack)			1/6 implied			sprintf(output,"RTS");len=1;			break;		case 0x61:	//	ADC	A <- A + M + C			2/6 zero page indexed indirect, X			sprintf(output,"ADC %2lX,X^",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x65:	//	ADC	A <- A + M + C			2/2 zero page			sprintf(output,"ADC #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x66:	// C<-A0 & A<- (A7=C + A>>1)	2/5 zero page			sprintf(output,"ROR %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x68:	//	PLA	A <- (STACK)			1/4 implied			sprintf(output,"PLA");len=1;			break;		case 0x69:	//	ADC	A <- A + M + C			2/2 immediate			sprintf(output,"ADC #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x6A:	// C<-A0 & A<- (A7=C + A>>1)	1/2 accumulator			sprintf(output,"ROR");len=1;			break;		case 0x6C:	//	PC <- Address					3/5 absolute indirect			sprintf(output,"JMP %4lX^",(long int)MEMREADWORD(pc));len=3;			break;		case 0x6D:	//	ADC	A <- A + M + C			3/4 absolute			sprintf(output,"ADC #%4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x6E:	// C<-A0 & A<- (A7=C + A>>1)	3/6 absolute			sprintf(output,"ROR #%4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x70:	//	BVS	if V=1, PC = PC + offset	2/2 relative			cdata = MEMREADBYTE(pc);			temp = 1+pc+cdata;			sprintf(output,"BVS *%c%02lX     ; %04X",(cdata<0)?'-':'+',(long int)((cdata<0)?(-cdata):cdata),temp);			len=2;			break;		case 0x71:	//	ADC	A <- A + M + C			2/5 zero page indirect indexed, Y			sprintf(output,"ADC %2lX^,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x75:	//	ADC	A <- A + M + C			2/4 zero page indexed, X			sprintf(output,"ADC %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x76:	// C<-A0 & A<- (A7=C + A>>1)	2/6 zero page indexed, X			sprintf(output,"ROR %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x78:	//	SEI	I <- 1 					1/2 implied			sprintf(output,"SEI");len=1;			break;		case 0x79:	//	ADC	A <- A + M + C			3/4 absolute indexed, Y			sprintf(output,"ADC #%4lX,Y",(long int)MEMREADWORD(pc));len=3;			break;		case 0x7D:	//	ADC	A <- A + M + C			3/4 absolute indexed, X			sprintf(output,"ADC #%4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0x7E:	// C<-A0 & A<- (A7=C + A>>1)	3/7 absolute indexed, X			sprintf(output,"ROR #%4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0x81:	//	STA	M <- A					2/6 zero page indexed indirect, X			sprintf(output,"STA %2lX,X^",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x84:	//	STY	M <- Y					2/3 zero page			sprintf(output,"STY %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x85:	//	STA	M <- A					2/3 zero page			sprintf(output,"STA %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x86:	//	STX	M <- X					2/3 zero page			sprintf(output,"STX %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x88:	//	DEY	Y <- Y - 1				1/2 implied			sprintf(output,"DEY");len=1;			break;		case 0x89:	//	NOP								1/2 immediate			sprintf(output,"NOP");len=1;			break;		case 0x8A:	//	TXA	A <- X					1/2 implied			sprintf(output,"TXA");len=1;			break;		case 0x8C:	//	STY	M <- Y					3/4 absolute			sprintf(output,"STY %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x8D:	//	STA	M <- A					3/4 absolute			sprintf(output,"STA %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x8E:	//	STX	M <- X					3/4 absolute			sprintf(output,"STX %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0x90:	//	BCC	if C=0, PC = PC + offset	2/2 relative			cdata = MEMREADBYTE(pc);			temp = 1+pc+cdata;			sprintf(output,"BCC *%c%02lX     ; %04X",(cdata<0)?'-':'+',(long int)((cdata<0)?(-cdata):cdata),temp);			len=2;			break;		case 0x91:	//	STA	M <- A					2/6 zero page indirect indexed, Y			sprintf(output,"STA %2lX^,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x94:	//	STY	M <- Y					2/4 zero page indexed, X			sprintf(output,"STY %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x95:	//	STA	M <- A					2/4 zero page indexed, X			sprintf(output,"STA %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;			case 0x96:	//	STX	M <- X					2/4 zero page indexed, Y			sprintf(output,"STX %2lX,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0x98:	//	TYA	A <- Y					1/2 implied			sprintf(output,"TYA");len=1;			break;		case 0x99:	//	STA	M <- A					3/5 absolute indexed, Y			sprintf(output,"STA %4lX,Y",(long int)MEMREADWORD(pc));len=3;			break;		case 0x9A:	//	TXS	S <- X					1/2 implied			sprintf(output,"TXS");len=1;			break;		case 0x9D:	//	STA	M <- A					3/5 absolute indexed, X			sprintf(output,"STA %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0xA0:	//	LDY	Y <- M					2/2 immediate			sprintf(output,"LDY #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xA1:	//	LDA	A <- M					2/6 zero page indexed indirect, X			sprintf(output,"LDA %2lX,X^",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xA2:	//	LDX	X <- M					2/2 immediate			sprintf(output,"LDX #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xA4:	//	LDY	Y <- M					2/3 zero page			sprintf(output,"LDY %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xA5:	//	LDA	A <- M					2/3 zero page			sprintf(output,"LDA %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xA6:	//	LDX	X <- M					2/3 zero page			sprintf(output,"LDX %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xA8:	//	TAY	Y <- A					1/2 implied			sprintf(output,"TAY");len=1;			break;		case 0xA9:	//	LDA	A <- M					2/2 immediate			sprintf(output,"LDA #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xAA:	//	TAX	X <- A					1/2 implied			sprintf(output,"TAX");len=1;			break;		case 0xAC:	//	LDY	Y <- M					3/4 absolute			sprintf(output,"LDY %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0xAD:	//	LDA	A <- M					3/4 absolute			sprintf(output,"LDA %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0xAE:	//	LDX	X <- M					3/4 absolute			sprintf(output,"LDX %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0xB0:	//	BCS	if C=1, PC = PC + offset	2/2 relative			cdata = MEMREADBYTE(pc);			temp = 1+pc+cdata;			sprintf(output,"BCS *%c%02lX     ; %04X",(cdata<0)?'-':'+',(long int)((cdata<0)?(-cdata):cdata),temp);			len=2;			break;		case 0xB1:	//	LDA	A <- M					2/5 zero page indirect indexed, Y			sprintf(output,"LDA %2lX^,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xB4:	//	LDY	M <- Y					2/4 zero page indexed, X			sprintf(output,"LDY %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xB5:	//	LDA	A <- M					2/4 zero page indexed, X			sprintf(output,"LDA %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xB6:	//	LDX	X <- M					2/4 zero page indexed, Y			sprintf(output,"LDX %2lX,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xB8:	//	CLV	V <- 0					1/2 implied			sprintf(output,"CLV");len=1;			break;		case 0xB9:	//	LDA	A <- M					3/4 absolute indexed, Y			sprintf(output,"LDA %4lX,Y",(long int)MEMREADWORD(pc));len=3;			break;		case 0xBA:	//	TSX	X <- S					1/2 implied			sprintf(output,"TSX");len=1;			break;		case 0xBC:	//	LDY	Y <- M					3/4 absolute indexed, X			sprintf(output,"LDY %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0xBD:	//	LDA	A <- M					3/4 absolute indexed, X			sprintf(output,"LDA %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0xBE:	//	LDX	X <- M					3/4 absolute indexed, Y			sprintf(output,"LDX %4lX,Y",(long int)MEMREADWORD(pc));len=3;			break;		case 0xC0:	//	CPY	(Y - M) -> NZC			2/2 immediate			sprintf(output,"CPY #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xC1:	//	CMP	(A - M) -> NZC			2/6 zero page indexed indirect, X			sprintf(output,"CMP %2lX,X^",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xC4:	//	CPY	(Y - M) -> NZC			2/3 zero page			sprintf(output,"CPY %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xC5:	//	CMP	(A - M) -> NZC			2/3 zero page			sprintf(output,"CMP %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xC6:	//	DEC	M <- M -1				2/5 zero page			sprintf(output,"DEC %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xC8:	//	INY	Y <- Y + 1				1/2 implied			sprintf(output,"INY");len=1;			break;		case 0xC9:	//	CMP	(A - M) -> NZC			2/2 immediate			sprintf(output,"CMP %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xCA:	//	DEX	X <- (X - 1)			1/2 implied			sprintf(output,"DEX");len=1;			break;		case 0xCC:	//	CPY	(Y - M) -> NZC			3/4 absolute			sprintf(output,"CPY %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0xCD:	//	CMP	(A - M) -> NZC			3/4 absolute			sprintf(output,"CMP %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0xCE:	//	DEC	M <- M - 1				3/6 absolute			sprintf(output,"DEC %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0xD1:	//	CMP	(A - M) -> NZC			2/5 zero page indirect indexed, Y			sprintf(output,"CMP %2lX^,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xD0:	//	BNE	if Z=0, PC = PC + offset	2/2 relative			cdata = MEMREADBYTE(pc);			temp = 1+pc+cdata;			sprintf(output,"BNE *%c%02lX     ; %04X",(cdata<0)?'-':'+',(long int)((cdata<0)?(-cdata):cdata),temp);			len=2;			break;		case 0xD5:	//	CMP	(A - M) -> NZC			2/4 zero page indexed, X			sprintf(output,"CMP %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xD6:	//	DEC	M <- M - 1				2/6 zero page indexed, X			sprintf(output,"DEC %2lX,X",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xD8:	//	CLD	D <- 0					1/2 implied			sprintf(output,"CLD");len=1;			break;		case 0xD9:	//	CMP	(A - M) -> NZC			3/4 absolute indexed, Y			sprintf(output,"CMP %4lX,Y",(long int)MEMREADWORD(pc));len=3;			break;		case 0xDD:	//	CMP	(A - M) -> NZC			3/4 absolute indexed, X			sprintf(output,"CMP %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0xDE:	//	DEC	M <- M - 1				3/7 absolute indexed, X			sprintf(output,"DEC %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0xE0:	//	CPX	(X - M) -> NZC			2/2 immediate			sprintf(output,"CPX #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xE1:	//	A <- A - M - ~C				2/6 zero page indexed indirect, X			sprintf(output,"SBC %2lX,X^",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xE4:	//	CPX	(X - M) -> NZC			2/3 zero page			sprintf(output,"CPX #%2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xE5:	//	A <- A - M - ~C				2/3 zero page			sprintf(output,"SBC %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xE6:	//	INC	M <- M + 1				2/5 zero page			sprintf(output,"INC %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xE8:	//	INX	X <- X + 1				1/2 implied			sprintf(output,"INX");len=1;			break;		case 0xE9:	//	A <- A - M - ~C				2/2 immediate			sprintf(output,"SBC %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xEA:	//	NOP								1/2 implied			sprintf(output,"NOP");len=1;			break;		case 0xEC:	//	CPX	(X - M) -> NZC			3/4 absolute			sprintf(output,"CPX #%4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0xED:	// A <- A - M - ~C				3/4 absolute			sprintf(output,"SBC %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0xEE:	//	INC	M <- M + 1				3/6 absolute			sprintf(output,"INC %4lX",(long int)MEMREADWORD(pc));len=3;			break;		case 0xF0:	//	BEQ	if Z=1, PC = PC + offset	2/2 relative			cdata = MEMREADBYTE(pc);			temp = 1+pc+cdata;			sprintf(output,"BEQ *%c%02lX     ; %04X",(cdata<0)?'-':'+',(long int)((cdata<0)?(-cdata):cdata),temp);			len=2;			break;		case 0xF1:	//	A <- A - M - ~C				2/5 zero page indirect indexed, Y			sprintf(output,"SBC %2lX^,Y",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xF5:	//	A <- A - M - ~C				2/4 zero page indexed, X			sprintf(output,"SBC %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xF6:	//	INC	M <- M + 1				2/6 zero page indexed, X			sprintf(output,"INC %2lX",(long int)MEMREADBYTE(pc));len=2;			break;		case 0xF8:	//	SED	D <- 0					1/2 implied			sprintf(output,"SED");len=1;			break;		case 0xF9:	//	A <- A - M - ~C				3/4 absolute indexed, Y			sprintf(output,"SBC #%4lX,Y",(long int)MEMREADWORD(pc));len=3;			break;		case 0xFD:	// A <- A - M - ~C				3/4 absolute indexed, X			sprintf(output,"SBC %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		case 0xFE:	//	INC	M <- M + 1				3/7 absolute indexed, X			sprintf(output,"INC %4lX,X",(long int)MEMREADWORD(pc));len=3;			break;		default:			sprintf(output,"UNKNOWN");len=1;			break;	}		return len;}