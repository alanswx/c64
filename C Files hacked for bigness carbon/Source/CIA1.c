/*-------------------------------------------------------------------------------*\||	File:	CIA1.c||	Description:||||||	Copyright ï¿½	1994, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include "DebugWindow.h"#include "Interrupts.h"#include	"Keyboard.h"#include	"JoyStick.h"#include "CPU.h"#include "CIA1.h"/*	local constants	*/#define	kCIA1BaseAddress	0x0000DC00#define	LOCALDEBUG			0/*	external globals	*/extern KeyboardScanMask	gKeyMask;			//	Keyboard.cextern Boolean				gEnableJoyA, gEnableJoyB;#if	DEBUG	extern	Boolean	gVerbose;#endif/*	local globals	*/unsigned char	gCIA1Reg[16];CIA1ICR			gCIA1IRQICR;CIA1ICR			gCIA1MaskICR;CIA1CRA			gCIA1CRegA;CIA1CRB			gCIA1CRegB;CIA1TimerLatch	gCIA1TimerALatch;long				gCIA1TimerACount;void CIA1Write(unsigned long address,unsigned long value){	register	unsigned long	reg;	register	unsigned long	val;			val = value;	reg = (address-kCIA1BaseAddress)&0x0F;	    //fprintf(stderr,"CIA1Write %lx %lx reg: %lx\n",address,value,reg);	switch(reg)	{		case 0x00:		//	Data Port A (Keyboard, Joystick, Paddles, Light-Pen)			//gKeyMask.byte = (val& gCIA1Reg[0x02]);			gKeyMask.byte = val;			//debug_window_printf("CIA1 00 write: %2lX",(long int)val);			break;		case 0x01:		//	Data Port B (Keyboard, Joystick, Paddles): Game Port 1			//debug_window_printf("CIA1 01 write: %2lX",(long int)val);			break;		case 0x02:		//	Data Direction Register -- Port A			//debug_window_printf("port a DDR write: %2lX",(long int)val);			break;		case 0x03:		//	Data Direction Register -- Port B			//debug_window_printf("port b DDR write: %2lX",(long int)val);			break;		case 0x04:		//	Timer A: Low-Byte			//	store low byte of timer latch			gCIA1TimerALatch.bytes.low = val;			break;		case 0x05:		//	Timer A: High-Byte			//	store high byte of timer latch and store latch into counter			gCIA1TimerALatch.bytes.high = val;			gCIA1TimerACount = htonl(gCIA1TimerALatch.val);			         //   fprintf(stderr,"set CIA timer %ld\n",gCIA1TimerACount);			//	if timer is running, restart it with new value//			if (gCIA1CRegA.bits.start)            if (gCIA1CRegA.byte & 0x01)				SetCIA1TimerAInterruptCounter(gCIA1TimerACount);			break;		case 0x06:		//	Timer B: Low-Byte			break;		case 0x07:		//	Timer B: High-Byte			break;		case 0x08:		//	Time-of-Day Clock: 1/10 Seconds			break;		case 0x09:		//	Time-of-Day Clock: Seconds			break;		case 0x0A:		//	Time-of-Day Clock: Minutes			break;		case 0x0B:		//	Time-of-Day Clock: Hours + AM/PM Flag (Bit 7)			break;		case 0x0C:		//	Synchronous Serial I/O Data Buffer			break;		case 0x0D:		//	CIA Interrupt Control Register (Read IRQs/Write Mask			if (val & 0x80)				gCIA1MaskICR.byte |= (val & 0x1F);				else				gCIA1MaskICR.byte &= ~(val & 0x1F);				break;		case 0x0E:		//	CIA Control Register A//            gCIA1CRegA.byte = (val & 0xEF);            gCIA1CRegA.byte = (val & 0x00FF);			if (val & 0x10)			{				//	force load timer counter with latch value				gCIA1TimerACount = htonl(gCIA1TimerALatch.val);								//	if timer is running, restart it with new value                //if (gCIA1CRegA.bits.start)                if (gCIA1CRegA.byte & 0x01)                {					SetCIA1TimerAInterruptCounter(gCIA1TimerACount);                }			}			break;		case 0x0F:		//	CIA Control Register B			gCIA1CRegB.byte = (val & 0xEF);          //  fprintf(stderr,"gCIA1CRegB %x val %lx\n",gCIA1CRegB.byte, val);			if (val & 0x10)				;//	do timer force load			break;		default:			break;	}		#if	LOCALDEBUG && DEBUG		//6debug_window_printf("CIA1Write: reg: %X, val: %X",(int)reg,(int)val);	#endif	gCIA1Reg[reg] = val;}//#ifndef	powerc//unsigned long CIA1Read(unsigned long address:__A0)//#elseunsigned long CIA1Read(unsigned long address)//#endif{	register	unsigned long	reg;	register	unsigned long	val;    //fprintf(stderr,"CIA1Read %lx\n",address);		reg = (address-kCIA1BaseAddress)&0x0F;	val = gCIA1Reg[reg];	    //fprintf(stderr,"CIA1Read %lx reg %lx val %lx\n",reg,val,address);    	switch(reg)	{		case 0x00:		//	Data Port A (Keyboard, Joystick, Paddles, Light-Pen)			val = ReadKeyboardRow();			if (gEnableJoyA)				val &= ReadJoyStick1();						//	val &= 	~gCIA1Reg[0x02];			break;		case 0x01:		//	Data Port B (Keyboard, Joystick, Paddles): Game Port 1			val = ReadKeyboardRow();			if (gEnableJoyB)				val &= ReadJoyStick1();		//	val &= 	~gCIA1Reg[0x03];			break;		case 0x02:		//	Data Direction Register -- Port A			break;		case 0x03:		//	Data Direction Register -- Port B			break;		case 0x04:		//	Timer A: Low-Byte			val = gCIA1TimerALatch.bytes.low;			break;		case 0x05:		//	Timer A: High-Byte			val = gCIA1TimerALatch.bytes.high;			break;		case 0x06:		//	Timer B: Low-Byte			#if	LOCALDEBUG && DEBUG				debug_window_printf("trying to read timerb");			#endif			break;		case 0x07:		//	Timer B: High-Byte			#if	LOCALDEBUG && DEBUG				debug_window_printf("trying to read timerb");			#endif			break;		case 0x08:		//	Time-of-Day Clock: 1/10 Seconds			break;		case 0x09:		//	Time-of-Day Clock: Seconds			break;		case 0x0A:		//	Time-of-Day Clock: Minutes			break;		case 0x0B:		//	Time-of-Day Clock: Hours + AM/PM Flag (Bit 7)			break;		case 0x0C:		//	Synchronous Serial I/O Data Buffer			break;		case 0x0D:		//	CIA Interrupt Control Register (Read IRQs/Write Mask)			val = gCIA1IRQICR.byte;			gCIA1IRQICR.byte = 0;			break;		case 0x0E:		//	CIA Control Register A			val = gCIA1CRegA.byte;			break;		case 0x0F:		//	CIA Control Register B			val = gCIA1CRegB.byte;			break;		default:			break;	}		#if	LOCALDEBUG && DEBUG	//	debug_window_printf("CIA1Read: reg: %X, val: %X",(int)reg,(int)val);	#endif	gCIA1Reg[reg] = val;	return val;}void CIA1TimerAExpire(void){		//	they turned off the timer, so ignore it	//if (!gCIA1CRegA.bits.start)    if (!gCIA1CRegA.byte & 0x01)		return;		//	load timer counter with latch value on underflow	gCIA1TimerACount = htonl(gCIA1TimerALatch.val);		//	restart timer counting if in continous run mode    //if (gCIA1CRegA.bits.RUNMode)        if (gCIA1CRegA.byte & 0x08)        gCIA1CRegA.byte = gCIA1CRegA.byte  | 0x01;		//gCIA1CRegA.bits.start = 0;	else		SetCIA1TimerAInterruptCounter(gCIA1TimerACount);		//	set interrupt bit and cause interrupt if enabled	//gCIA1IRQICR.bits.timerA = 1;    gCIA1IRQICR.byte = gCIA1IRQICR.byte | 0x01;    //    if (gCIA2MaskICR.bits.timerA && !gCIA2NMIICR.bits.NMIFlag)    if ((gCIA1MaskICR.byte & kTimerABitFlag) && !(gCIA1IRQICR.byte & 0x80))	//if (gCIA1MaskICR.bits.timerA && !gCIA1IRQICR.bits.IRQFlag)	{       // gCIA1IRQICR.bits.IRQFlag = 1;        gCIA1IRQICR.byte &= ~(1<<7);		IRQInterrupt();	}}extern unsigned long		gPCRegister; short CIA1InterruptPending(void){	//	is there a pending/latched interrupt on CIA1?    return gCIA1IRQICR.byte & 0x80;//	return gCIA1IRQICR.bits.IRQFlag;}