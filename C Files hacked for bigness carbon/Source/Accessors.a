	CASE OBJ	MACHINE MC68020	INCLUDE 'Traps.a'	IMPORT		gMemRead:DATA	IMPORT		gMemWrite:DATA	IMPORT		PageZeroWrite:CODE	EXPORT		READTable:CODE	EXPORT		MReadByte:CODE	EXPORT		MReadWord:CODE	EXPORT		WRITETable:CODE	EXPORT		MWriteByte:CODEMReadByte		PROC	EXPORT		READTable:CODE		MOVE.L		A0,D1								; get our play copy	MOVEQ		#12,D0								; setup for nybble shift	LSR.W		D0,D1								; shift high nybble into low nybble	MOVE.L		(READTable,D1.L*4),D1				; magically get base address into D1	BEQ.S		@DOVECTORREAD						; handle vectored read	ADD.L		D1,A0								; add offset to base address	MOVE.B		(A0),D0								; fetch byte	RTS@DOVECTORREAD	MOVE.L		A0,D0								; load address for memory accessor	LSR.W		#$08,D0								; compute address page	MOVEA.L		gMemRead,A1							; load vector table base	JMP			([$00,A1,D0.L*$04])					; fetch byte from memory via vectorREADTable:	DS.L	16	ENDPROCMReadWord		PROC	IMPORT		READTable:CODE		MOVE.L		A0,D1								; get our play copy	MOVEQ		#12,D0								; setup for nybble shift	LSR.W		D0,D1								; shift high nybble into low nybble	MOVE.L		(READTable,D1.L*4),D1				; magically get base address into D1	BEQ.S		@DOVECTORREAD						; handle vectored read	ADD.L		D1,A0								; add offset to base address	MOVE.W		(A0),D0								; fetch byte	ROL.W		#$08,D0								; flip bytes for big endies	RTS@DOVECTORREAD	_Debugger	MOVE.L		A0,D0								; load address for memory accessor	LSR.W		#$08,D0								; compute address page	MOVEA.L		gMemRead,A1							; load vector table base	JMP			([$00,A1,D0.L*$04])					; fetch byte from memory via vector	ENDPROCMWriteByte		PROC	EXPORT		WRITETable:CODE		MOVE.L		A0,D1								; get our play copy	LSR.W		#1,D1								; check for 0 or 1	BEQ.S		@DOZPVECTORWRITE					; handle 0 or 1 case	MOVEQ		#11,D0								; setup for nybble shift	LSR.W		D0,D1								; shift high nybble into low nybble	MOVE.L		(WRITETable,D1.L*4),D1				; magically get base address into D1	BEQ.S		@DOVECTORWRITE						; handle vectored read	ADD.L		D1,A0								; add offset to base address	MOVE.B		D2,(A0)								; store byte	RTS	@DOZPVECTORWRITE	MOVE.L		D2,-(SP)							; push argument: value	MOVE.L		A0,-(SP)							; push argument: address	JSR			PageZeroWrite						; store byte to memory via vector	ADDQ.W		#$08,SP								; clean up the stack	RTS@DOVECTORWRITE	MOVE.L		D2,-(SP)	MOVE.L		A0,-(SP)	MOVE.L		A0,D0								; load address for memory accessor	LSR.W		#$08,D0								; compute address page	MOVEA.L		gMemWrite,A1						; load vector table base	JSR			([$00,A1,D0.L*$04])					; fetch byte from memory via vector	ADDQ.W		#$08,SP								; clean up the stack	RTS	WRITETable:	DS.L	16	ENDPROC	END