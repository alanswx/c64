/*-------------------------------------------------------------------------------*\||	File:	CPU.c||	Description:||||||	Copyright ï¿½	1994, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include <stdio.h>#include <string.h>#include "DebugWindow.h"#include "Disassembler.h"#include "Accessors.h"#include "Memory.h"#include "Interrupts.h"#include "Traps.h"#include "CPU.h"// ---------------------------------//	| N | V |   | B | D | I | Z | C |	flag byte // ---------------------------------/*	local constants/macros	*/#define	kResetVector		0xFFFC#define	kIRQVector			0xFFFE#define	kBRKVector			0xFFFE#define	ACC					gCPUAccumulator#define	INDX					gCPUIndexX#define	INDY					gCPUIndexY#define	STACK					gCPUStack#define	PC						gCPUPC#define	FLAGS					gCPUFlags#define	POPBYTE()			MEMREADBYTE(STACK+257);STACK=(unsigned char)STACK+1#define	POPWORD()			MEMREADWORD(STACK+257);STACK=(unsigned char)STACK+2#define	PUSHBYTE(x)			MEMWRITEBYTE((STACK+256),x);STACK=(unsigned char)STACK-1#define	PUSHWORD(x)			STACK=(unsigned char)STACK-1;MEMWRITEWORD((STACK+256),x);STACK=(unsigned char)STACK-1#define	BITN					0x80#define	BITV					0x40#define	BITB					0x10#define	BITD					0x08#define	BITI					0x04#define	BITZ					0x02#define	BITC					0x01#define	CLEARFLAGD()		FLAGS &= ~BITD#define	CLEARFLAGC()		FLAGS &= ~BITC#define	CLEARFLAGI()		FLAGS &= ~BITI#define	CLEARFLAGV()		FLAGS &= ~BITV#define	CLEARFLAGNZ()		FLAGS &= ~(BITN+BITZ)#define	CLEARFLAGNVZ()		FLAGS &= ~(BITN+BITV+BITZ)#define	CLEARFLAGNZC()		FLAGS	&= ~(BITN+BITZ+BITC)#define	CLEARFLAGNVZC()	FLAGS &= ~(BITN+BITV+BITZ+BITC)#define	SETFLAGN()			FLAGS |= BITN#define	SETFLAGI()			FLAGS |= BITI#define	SETFLAGZ()			FLAGS |= BITZ#define	SETFLAGC()			FLAGS |= BITC#define	SETFLAGV()			FLAGS |= BITV#define	SETFLAGB()			FLAGS |= BITB#define	SETFLAGD()			FLAGS |= BITD#define	TESTFLAGN()			(FLAGS & BITN)#define	TESTFLAGB()			(FLAGS & BITB)#define	TESTFLAGZ()			(FLAGS & BITZ)#define	TESTFLAGC()			(FLAGS & BITC)#define	TESTFLAGD()			(FLAGS & BITD)#define	TESTFLAGI()			(FLAGS & BITI)#define	TESTFLAGV()			(FLAGS & BITV)/*	local type definitions	*/#define	COUNT_OPS	0/*	external globals	*/extern ReadHandler			*gMemRead;							//	Memory.cextern WriteHandler			*gMemWrite;							//	Memory.cextern unsigned char			*gRAMBlock;							//	Memory.cextern long						gInterruptFlag;					// Interrupts.cextern unsigned long			gACCRegister;						//	CPUState.cextern unsigned long			gINXRegister;						//	CPUState.cextern unsigned long			gINYRegister;						//	CPUState.cextern unsigned long			gSTACKRegister;					//	CPUState.cextern unsigned long			gPCRegister;						//	CPUState.cextern unsigned long			gSRRegister;						//	CPUState.c#if	DEBUGextern	Boolean	gVerbose;#endif/*	local globals	*/OpFunc			gOPs[256];unsigned char	ACC;unsigned char	INDX;unsigned char	INDY;unsigned char	STACK;unsigned short	PC;unsigned char	FLAGS;long	gStartTicks;unsigned long	one = 0;unsigned long	two = 0;unsigned long	thr = 0;////	Initialize the C version of the CPU loop, this involves//	filling in OPCode vectors in the dispatch table//void InitCPU(void){	short	index;			for (index=0;index<256;index++)		gOPs[index] = CPUOP_UnimplementedOP;		gOPs[0x00] = CPUOP_00_BRK;	gOPs[0x01] = CPUOP_01_ORA;	gOPs[0x04] = CPUOP_04_NOP;	gOPs[0x05] = CPUOP_05_ORA;	gOPs[0x06] = CPUOP_06_ASL;	gOPs[0x07] = CPUOP_07_ASO;	gOPs[0x08] = CPUOP_08_PHP;	gOPs[0x09] = CPUOP_09_ORA;	gOPs[0x0A] = CPUOP_0A_ASL;	gOPs[0x0C] = CPUOP_0C_NOP;	gOPs[0x0D] = CPUOP_0D_ORA;	gOPs[0x0E] = CPUOP_0E_ASL;	gOPs[0x10] = CPUOP_10_BPL;	gOPs[0x11] = CPUOP_11_ORA;	gOPs[0x14] = CPUOP_14_NOP;	gOPs[0x15] = CPUOP_15_ORA;	gOPs[0x16] = CPUOP_16_ASL;	gOPs[0x18] = CPUOP_18_CLC;	gOPs[0x19] = CPUOP_19_ORA;	gOPs[0x1D] = CPUOP_1D_ORA;	gOPs[0x1E] = CPUOP_1E_ASL;	gOPs[0x20] = CPUOP_20_JSR;	gOPs[0x21] = CPUOP_21_AND;	gOPs[0x24] = CPUOP_24_BIT;	gOPs[0x25] = CPUOP_25_AND;	gOPs[0x26] = CPUOP_26_ROL;	gOPs[0x28] = CPUOP_28_PLP;	gOPs[0x29] = CPUOP_29_AND;	gOPs[0x2A] = CPUOP_2A_ROL;	gOPs[0x2C] = CPUOP_2C_BIT;	gOPs[0x2D] = CPUOP_2D_AND;	gOPs[0x2E] = CPUOP_2E_ROL;	gOPs[0x30] = CPUOP_30_BMI;	gOPs[0x31] = CPUOP_31_AND;	gOPs[0x35] = CPUOP_35_AND;	gOPs[0x36] = CPUOP_36_ROL;	gOPs[0x38] = CPUOP_38_SEC;	gOPs[0x39] = CPUOP_39_AND;	gOPs[0x3C] = CPUOP_3C_NOP;	gOPs[0x3D] = CPUOP_3D_AND;	gOPs[0x3E] = CPUOP_3E_ROL;	gOPs[0x3F] = CPUOP_3F_RLA;	gOPs[0x40] = CPUOP_40_RTI;	gOPs[0x41] = CPUOP_41_EOR;	gOPs[0x44] = CPUOP_44_NOP;		gOPs[0x45] = CPUOP_45_EOR;	gOPs[0x46] = CPUOP_46_LSR;	gOPs[0x48] = CPUOP_48_PHA;	gOPs[0x49] = CPUOP_49_EOR;	gOPs[0x4A] = CPUOP_4A_LSR;	gOPs[0x4C] = CPUOP_4C_JMP;	gOPs[0x4D] = CPUOP_4D_EOR;	gOPs[0x4E] = CPUOP_4E_LSR;	gOPs[0x4F] = CPUOP_4F_LSE;	gOPs[0x50] = CPUOP_50_BVC;	gOPs[0x51] = CPUOP_51_EOR;	gOPs[0x55] = CPUOP_55_EOR;	gOPs[0x56] = CPUOP_56_LSR;	gOPs[0x57] = CPUOP_57_LSE;	gOPs[0x58] = CPUOP_58_CLI;	gOPs[0x59] = CPUOP_59_EOR;	gOPs[0x5D] = CPUOP_5D_EOR;	gOPs[0x5E] = CPUOP_5E_LSR;	gOPs[0x60] = CPUOP_60_RTS;	gOPs[0x61] = CPUOP_61_ADC;	gOPs[0x65] = CPUOP_65_ADC;	gOPs[0x66] = CPUOP_66_ROR;	gOPs[0x67] = CPUOP_67_LSE;	gOPs[0x68] = CPUOP_68_PLA;	gOPs[0x69] = CPUOP_69_ADC;	gOPs[0x6A] = CPUOP_6A_ROR;	gOPs[0x6C] = CPUOP_6C_JMP;	gOPs[0x6D] = CPUOP_6D_ADC;	gOPs[0x6E] = CPUOP_6E_ROR;	gOPs[0x70] = CPUOP_70_BVS;	gOPs[0x71] = CPUOP_71_ADC;	gOPs[0x75] = CPUOP_75_ADC;	gOPs[0x76] = CPUOP_76_ROR;	gOPs[0x78] = CPUOP_78_SEI;	gOPs[0x79] = CPUOP_79_ADC;	gOPs[0x7D] = CPUOP_7D_ADC;	gOPs[0x7E] = CPUOP_7E_ROR;	gOPs[0x80] = CPUOP_80_NOP;	gOPs[0x81] = CPUOP_81_STA;	gOPs[0x84] = CPUOP_84_STY;	gOPs[0x85] = CPUOP_85_STA;	gOPs[0x86] = CPUOP_86_STX;	gOPs[0x87] = CPUOP_87_AXS;	gOPs[0x88] = CPUOP_88_DEY;	gOPs[0x8A] = CPUOP_8A_TXA;	gOPs[0x8C] = CPUOP_8C_STY;	gOPs[0x8D] = CPUOP_8D_STA;	gOPs[0x8E] = CPUOP_8E_STX;	gOPs[0x8F] = CPUOP_8F_SAX;	gOPs[0x90] = CPUOP_90_BCC;	gOPs[0x91] = CPUOP_91_STA;	gOPs[0x94] = CPUOP_94_STY;	gOPs[0x95] = CPUOP_95_STA;	gOPs[0x96] = CPUOP_96_STX;	gOPs[0x97] = CPUOP_97_AXS;	gOPs[0x98] = CPUOP_98_TYA;	gOPs[0x99] = CPUOP_99_STA;	gOPs[0x9A] = CPUOP_9A_TXS;	gOPs[0x9D] = CPUOP_9D_STA;	gOPs[0xA0] = CPUOP_A0_LDY;	gOPs[0xA1] = CPUOP_A1_LDA;	gOPs[0xA2] = CPUOP_A2_LDX;	gOPs[0xA4] = CPUOP_A4_LDY;	gOPs[0xA5] = CPUOP_A5_LDA;	gOPs[0xA6] = CPUOP_A6_LDX;	gOPs[0xA7] = CPUOP_A7_LAX;	gOPs[0xA8] = CPUOP_A8_TAY;	gOPs[0xA9] = CPUOP_A9_LDA;	gOPs[0xAA] = CPUOP_AA_TAX;	gOPs[0xAB] = CPUOP_AB_OAL;	gOPs[0xAC] = CPUOP_AC_LDY;	gOPs[0xAD] = CPUOP_AD_LDA;	gOPs[0xAE] = CPUOP_AE_LDX;	gOPs[0xAF] = CPUOP_AF_LAX;	gOPs[0xB0] = CPUOP_B0_BCS;	gOPs[0xB1] = CPUOP_B1_LDA;	gOPs[0xB3] = CPUOP_B3_LAX;	gOPs[0xB4] = CPUOP_B4_LDY;	gOPs[0xB5] = CPUOP_B5_LDA;	gOPs[0xB6] = CPUOP_B6_LDX;	gOPs[0xB8] = CPUOP_B8_CLV;	gOPs[0xB9] = CPUOP_B9_LDA;	gOPs[0xBA] = CPUOP_BA_TSX;	gOPs[0xBC] = CPUOP_BC_LDY;	gOPs[0xBD] = CPUOP_BD_LDA;	gOPs[0xBE] = CPUOP_BE_LDX;	gOPs[0xBF] = CPUOP_BF_LAX;	gOPs[0xC0] = CPUOP_C0_CPY;	gOPs[0xC1] = CPUOP_C1_CMP;	gOPs[0xC3] = CPUOP_C3_DCM;	gOPs[0xC4] = CPUOP_C4_CPY;	gOPs[0xC5] = CPUOP_C5_CMP;	gOPs[0xC6] = CPUOP_C6_DEC;	gOPs[0xC7] = CPUOP_C7_DCM;	gOPs[0xC8] = CPUOP_C8_INY;	gOPs[0xC9] = CPUOP_C9_CMP;	gOPs[0xCA] = CPUOP_CA_DEX;	gOPs[0xCC] = CPUOP_CC_CPY;	gOPs[0xCD] = CPUOP_CD_CMP;	gOPs[0xCE] = CPUOP_CE_DEC;	gOPs[0xD0] = CPUOP_D0_BNE;	gOPs[0xD1] = CPUOP_D1_CMP;	gOPs[0xD5] = CPUOP_D5_CMP;	gOPs[0xD6] = CPUOP_D6_DEC;	gOPs[0xD8] = CPUOP_D8_CLD;	gOPs[0xDD] = CPUOP_DD_CMP;	gOPs[0xD9] = CPUOP_D9_CMP;	gOPs[0xDE] = CPUOP_DE_DEC;	gOPs[0xE0] = CPUOP_E0_CPX;	gOPs[0xE1] = CPUOP_E1_SBC;	gOPs[0xE4] = CPUOP_E4_CPX;	gOPs[0xE5] = CPUOP_E5_SBC;	gOPs[0xE6] = CPUOP_E6_INC;	gOPs[0xE7] = CPUOP_E7_INS;	gOPs[0xE8] = CPUOP_E8_INX;	gOPs[0xE9] = CPUOP_E9_SBC;	gOPs[0xEA] = CPUOP_EA_NOP;	gOPs[0xEC] = CPUOP_EC_CPX;	gOPs[0xED] = CPUOP_ED_SBC;	gOPs[0xEE] = CPUOP_EE_INC;	gOPs[0xF0] = CPUOP_F0_BEQ;	gOPs[0xF1] = CPUOP_F1_SBC;	gOPs[0xF3] = CPUOP_F3_INS;	gOPs[0xF5] = CPUOP_F5_SBC;	gOPs[0xF6] = CPUOP_F6_INC;	gOPs[0xF8] = CPUOP_F8_SED;	gOPs[0xF9] = CPUOP_F9_SBC;	gOPs[0xFA] = CPUOP_FA_NOP;	gOPs[0xFC] = CPUOP_FC_NOP;	gOPs[0xFD] = CPUOP_FD_SBC;	gOPs[0xFE] = CPUOP_FE_INC;	gOPs[0xFF] = CPUOP_FF_TRP;}////	Do any house cleaning that the C version of the CPU might need//void CleanUpCPU(void){	}#include "Combug.h"void CPU(void){	register unsigned long	op;		ACC = gACCRegister;	INDX = gINXRegister;	INDY = gINYRegister;	STACK = gSTACKRegister;	PC = gPCRegister;	FLAGS = gSRRegister;	while(1)	{		op = MEMREADBYTE(PC);#if 0        // print disassembly as we run        char line[4096];        unsigned short res =DisasmOneOpcode(line,PC);        fprintf(stderr,"pc = %x op = %x (%s) %d\n",PC,op,line,res);#endif		PC++;		gInterruptFlag -= gOPs[op]();		if ((gInterruptFlag < 0) && CPUInterruptCheck())			break;	}		gACCRegister = ACC;	gINXRegister = INDX;	gINYRegister = INDY;	gSTACKRegister = STACK;	gPCRegister = PC;	gSRRegister = FLAGS;}short CPUInterruptCheck(void){	short	result;			gSTACKRegister = STACK;	gPCRegister = PC;	gSRRegister = FLAGS;		result = InterruptCheck();		STACK = gSTACKRegister;	PC = gPCRegister;	FLAGS = gSRRegister;		return result;}void CPUCheckForLatchedInterrupts(void){	gSTACKRegister = STACK;	gPCRegister = PC;	gSRRegister = FLAGS;		CheckForLatchedInterrupts();		STACK = gSTACKRegister;	PC = gPCRegister;	FLAGS = gSRRegister;}////	Generic handler for unimplemented instructions//unsigned long CPUOP_UnimplementedOP(void){	#if	defined(DEBUG) && defined(LOCALDEBUG)		debug_window_printf("");		debug_window_printf("--> Unimplemented opcode:  $%lX",(long int)MEMREADBYTE(PC-1));	#endif	debug_window_printf("CPUOP_UnimplementedOP:  %lx",MEMREADBYTE(PC-1));    fprintf(stderr,"unimplemented opcode\n");//	DebugStr("\p--> Unimplemented opcode");//	ExitToShell();	return 2;}////	XXX #const//unsigned long CPUEA_Immediate(void){	return PC;}////	XXX addr//unsigned long CPUEA_Absolute(void){	return MEMREADWORD(PC);}////	XXX addr,X//unsigned long CPUEA_AbsoluteX(void){	return (unsigned short)(INDX + MEMREADWORD(PC));}////	XXX addr,Y//unsigned long CPUEA_AbsoluteY(void){	return (unsigned short)(INDY + MEMREADWORD(PC));}////	XXX (addr)//unsigned long CPUEA_AbsoluteIndirect(void){	return MEMREADWORD(MEMREADWORD(PC));}////	XXX zp//unsigned long CPUEA_ZeroPage(void){	return MEMREADBYTE(PC);}////	XXX zp,X//unsigned long CPUEA_ZeroPageX(void){	return (unsigned char)(INDX + MEMREADBYTE(PC));}////	XXX zp,Y//unsigned long CPUEA_ZeroPageY(void){	return (unsigned char)(INDY + MEMREADBYTE(PC));}////	XXX (zp,X)//unsigned long CPUEA_ZeroPageIndexedIndirectX(void){	return  MEMREADWORD((unsigned char)(INDX + MEMREADBYTE(PC)));}////	XXX (zp),Y//unsigned long CPUEA_ZeroPageIndirectIndexedY(void){	return (unsigned short)(INDY + MEMREADWORD(MEMREADBYTE(PC)));}////	$01 BRK - Software Break//	Addressing mode:	//	Flags affected:	//	Bytes/Cycles		1/7 with signature byte (2/7)//unsigned long CPUOP_00_BRK(void){	PC += 1;	PUSHWORD(PC);		SETFLAGB();	PUSHBYTE(FLAGS);	SETFLAGI();	PC = MEMREADWORD(kIRQVector);	//	debug_window_printf("software break!");		#if	COUNT_OPS	one++;	#endif		return 7;}////	$01 ORA - OR Accumulator with Memory//	Addressing mode:	zero page indexed indirect, X//	Flags affected:	n, z//	Bytes/Cycles		2/6//unsigned long CPUOP_01_ORA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndexedIndirectX();	temp = MEMREADBYTE(address);	ORA(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$04 NOP - No Operation//	Addressing mode:	zero page//	Flags affected:	none//	Bytes/Cycles		2/3//unsigned long CPUOP_04_NOP(void){	#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$05 ORA - OR Accumulator with Memory//	Addressing mode:	zero page//	Flags affected:	n, z//	Bytes/Cycles		2/3//unsigned long CPUOP_05_ORA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	ORA(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$06 ASL - Shift Memory Left//	Addressing mode:	zero page//	Flags affected:	n, z, c//	Bytes/Cycles		2/5//unsigned long CPUOP_06_ASL(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	temp = ASL(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}//	//	$07 ASO - ASL then ORA (Quasi-Opcode)//	Addressing mode:	zero page//	Flags affected:	n, z//	Bytes/Cycles		2/3//unsigned long CPUOP_07_ASO(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	temp = ASL(temp);	MEMWRITEBYTE(address,temp);	ORA(temp);	#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$08 PHP - Push Processor Status Register//	Addressing mode:	implied//	Flags affected:	none//	Bytes/Cycles		1/3//unsigned long CPUOP_08_PHP(void){	unsigned long	temp;			temp = (unsigned char)FLAGS;	PUSHBYTE(temp);		#if	COUNT_OPS	one++;	#endif		return 3;}////	$09 ORA - OR Accumulator with Memory//	Addressing mode:	immediate//	Flags affected:	n, z//	Bytes/Cycles		2/2//unsigned long CPUOP_09_ORA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Immediate();	temp = MEMREADBYTE(address);	ORA(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$0A ASL - Shift Accumulator Left//	Addressing mode:	accumulator//	Flags affected:	n, z, c//	Bytes/Cycles		1/2//unsigned long CPUOP_0A_ASL(void){	unsigned long	temp;			temp = ACC;	temp = ASL(temp);	ACC = (unsigned char)temp;			#if	COUNT_OPS	one++;	#endif		return 2;}////	$0C NOP - No Operation//	Addressing mode:	absolute//	Flags affected:	none//	Bytes/Cycles		3/4//unsigned long CPUOP_0C_NOP(void){	#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$0D ORA - OR Accumulator with Memory//	Addressing mode:	absolute//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_0D_ORA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	ORA(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$0E ASL - Shift Memory Left//	Addressing mode:	absolute//	Flags affected:	n, z, c//	Bytes/Cycles		3/6//unsigned long CPUOP_0E_ASL(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	temp = ASL(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 6;}////	$10 BPL - Branch If Plus//	Addressing mode:	relative//	Flags affected:	none//	Bytes/Cycles		2/2//unsigned long CPUOP_10_BPL(void){	unsigned long	address;	char	offset;			address = CPUEA_Immediate();	PC += 1;		if (!TESTFLAGN())	{		offset = MEMREADBYTE(address);		PC += offset;	}		#if	COUNT_OPS	two++;	#endif			return 2;}////	$11 ORA - OR Accumulator with Memory//	Addressing mode:	zero page indirect indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		2/5//unsigned long CPUOP_11_ORA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndirectIndexedY();	temp = MEMREADBYTE(address);	ORA(temp);		#if	COUNT_OPS	two++;	#endif			PC += 1;	return 5;}////	$14 NOP - No Operation//	Addressing mode:	zero page indexed, X//	Flags affected:	none//	Bytes/Cycles		2/4//unsigned long CPUOP_14_NOP(void){	PC += 1;		#if	COUNT_OPS	two++;	#endif		return 4;}////	$15 ORA - OR Accumulator with Memory//	Addressing mode:	zero page indexed, X//	Flags affected:	n, z//	Bytes/Cycles		2/4//unsigned long CPUOP_15_ORA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	ORA(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$16 ASL - Shift Memory Left//	Addressing mode:	zero page indexed, X//	Flags affected:	n, z, c//	Bytes/Cycles		2/6//unsigned long CPUOP_16_ASL(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	temp = ASL(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$18 CLC - Clear Carry Flag//	Addressing mode:	implied//	Flags affected:	c//	Bytes/Cycles		1/2//unsigned long CPUOP_18_CLC(void){	#if	COUNT_OPS	one++;	#endif		CLEARFLAGC();	return 2;}////	$19 ORA - OR Accumulator with Memory//	Addressing mode:	absolute indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_19_ORA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteY();	temp = MEMREADBYTE(address);	ORA(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$1D ORA - OR Accumulator with Memory//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_1D_ORA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	ORA(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$1E ASL - Shift Memory Left//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z, c//	Bytes/Cycles		3/7//unsigned long CPUOP_1E_ASL(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	temp = ASL(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 7;}////	$20 JSR - Jump to Subroutine//	Addressing mode:	absolute//	Flags affected:	none//	Bytes/Cycles		3/6//unsigned long CPUOP_20_JSR(void){	unsigned short	address;			address = CPUEA_Absolute();		PC += 1;	PUSHWORD(PC);	PC = (unsigned short)address;		#if	COUNT_OPS	thr++;	#endif		return 6;}////	$21 AND - And Accumulator with Memory//	Addressing mode:	zero page indexed indirect, X//	Flags affected:	n, z//	Bytes/Cycles		2/6//unsigned long CPUOP_21_AND(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndexedIndirectX();	temp = MEMREADBYTE(address);	AND(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$24 BIT - Test Memory Bits against Accumulator//	Addressing mode:	zero page//	Flags affected:	n, v, z//	Bytes/Cycles		2/3//unsigned long CPUOP_24_BIT(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	BIT(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$25 AND - And Accumulator with Memory//	Addressing mode:	zero page//	Flags affected:	n, z//	Bytes/Cycles		2/3//unsigned long CPUOP_25_AND(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	AND(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$26 ROL - Rotate Memory Left//	Addressing mode:	zero page//	Flags affected:	n, z, c//	Bytes/Cycles		2/5//unsigned long CPUOP_26_ROL(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	temp = ROL(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$28 PLP - Pull Status Flags (from stack)//	Addressing mode:	implied//	Flags affected:	n, v, b, d, i, z, c//	Bytes/Cycles		1/4//unsigned long CPUOP_28_PLP(void){	unsigned long	temp;			temp = POPBYTE();	FLAGS = temp;	FLAGS |= 0x20;		if (!TESTFLAGI())		CPUCheckForLatchedInterrupts();		#if	COUNT_OPS	one++;	#endif		return 4;}////	$29 AND - And Accumulator with Memory//	Addressing mode:	immediate//	Flags affected:	n, z//	Bytes/Cycles		2/2//unsigned long CPUOP_29_AND(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Immediate();	temp = MEMREADBYTE(address);	AND(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$2A ROL - Rotate Accumulator Left//	Addressing mode:	accumulator//	Flags affected:	n, z, c//	Bytes/Cycles		1/2//unsigned long CPUOP_2A_ROL(void){	unsigned long	temp;			temp = ACC;	temp = ROL(temp);	ACC = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$2C BIT - Test Memory Bits against Accumulator//	Addressing mode:	absolute//	Flags affected:	n, v, z//	Bytes/Cycles		3/4//unsigned long CPUOP_2C_BIT(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	BIT(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$2D AND - And Accumulator with Memory//	Addressing mode:	absolute//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_2D_AND(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	AND(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$2E ROL - Rotate Memory Left//	Addressing mode:	absolute//	Flags affected:	n, z, c//	Bytes/Cycles		3/6//unsigned long CPUOP_2E_ROL(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	temp = ROL(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 6;}////	$30 BMI - Branch If Minus//	Addressing mode:	relative//	Flags affected:	none//	Bytes/Cycles		2/2//unsigned long CPUOP_30_BMI(void){	unsigned long	address;	char	temp;			address = CPUEA_Immediate();	PC += 1;		if (TESTFLAGN())	{		temp = MEMREADBYTE(address);		PC += temp;	}		#if	COUNT_OPS	two++;	#endif		return 2;}////	$31 AND - And Accumulator with Memory//	Addressing mode:	zero page indirect indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		2/5//unsigned long CPUOP_31_AND(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndirectIndexedY();	temp = MEMREADBYTE(address);	AND(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$35 AND - And Accumulator with Memory//	Addressing mode:	zero page indexed, X//	Flags affected:	n, z//	Bytes/Cycles		2/4//unsigned long CPUOP_35_AND(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	AND(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$36 ROL - Rotate Memory Left//	Addressing mode:	zero page indexed, X//	Flags affected:	n, z, c//	Bytes/Cycles		2/6//unsigned long CPUOP_36_ROL(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	temp = ROL(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$38 SEC - Set Carry Flag//	Addressing mode:	implied//	Flags affected:	c//	Bytes/Cycles		1/2//unsigned long CPUOP_38_SEC(void){	#if	COUNT_OPS	one++;	#endif		SETFLAGC();	return 2;}////	$39 AND - And Accumulator with Memory//	Addressing mode:	absolute indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_39_AND(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteY();	temp = MEMREADBYTE(address);	AND(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$3C NOP - No Operation//	Addressing mode:	absolute indexed, X//	Flags affected:	none//	Bytes/Cycles		3/4//unsigned long CPUOP_3C_NOP(void){	#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$3D AND - And Accumulator with Memory//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_3D_AND(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	AND(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$3E ROL - Rotate Memory Left//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z, c//	Bytes/Cycles		3/7//unsigned long CPUOP_3E_ROL(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	temp = ROL(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 7;}////	$3F RLA - Rotate Memory Left and AND	(quasi-opcode)//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z, c//	Bytes/Cycles		3/7//unsigned long CPUOP_3F_RLA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	temp = ROL(temp);	AND(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 7;}////	$40 RTI - Return from Interrupt//	Addressing mode:	implied//	Flags affected:	none//	Bytes/Cycles		1/6//unsigned long CPUOP_40_RTI(void){	FLAGS = POPBYTE();	PC = POPWORD();		if (!TESTFLAGI())		CPUCheckForLatchedInterrupts();		#if	COUNT_OPS	one++;	#endif		return 6;}////	$41 EOR - Exclusive-OR Accumulator with Memory//	Addressing mode:	zero page indexed indirect, X//	Flags affected:	n, z//	Bytes/Cycles		2/6//unsigned long CPUOP_41_EOR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndexedIndirectX();	temp = MEMREADBYTE(address);	EOR(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$44 NOP - No Operation//	Addressing mode:	zero page//	Flags affected:	none//	Bytes/Cycles		2/3//unsigned long CPUOP_44_NOP(void){	#if	COUNT_OPS	thr++;	#endif		PC += 1;	return 3;}////	$45 EOR - Exclusive-OR Accumulator with Memory//	Addressing mode:	zero page//	Flags affected:	n, z//	Bytes/Cycles		2/3//unsigned long CPUOP_45_EOR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = (unsigned char)MEMREADBYTE(address);	EOR(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$46 LSR - Logical Shift Memory Right//	Addressing mode:	zero page//	Flags affected:	n, z, c//	Bytes/Cycles		2/5//unsigned long CPUOP_46_LSR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	temp = LSR(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$48 PHA - Push Accumulator (onto the stack)//	Addressing mode:	implied//	Flags affected:	none//	Bytes/Cycles		1/3//unsigned long CPUOP_48_PHA(void){	unsigned long	temp;			temp = ACC;	PUSHBYTE(temp);		#if	COUNT_OPS	one++;	#endif		return 3;}////	$49 EOR - Exclusive-OR Accumulator with Memory//	Addressing mode:	immediate//	Flags affected:	n, z//	Bytes/Cycles		2/2//unsigned long CPUOP_49_EOR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Immediate();	temp = (unsigned char)MEMREADBYTE(address);	EOR(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$4A LSR - Logical Shift Accumulator Right//	Addressing mode:	accumulator//	Flags affected:	n, z, c//	Bytes/Cycles		1/2//unsigned long CPUOP_4A_LSR(void){	unsigned long	temp;			temp = ACC;	temp = LSR(temp);	ACC = temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$4C JMP - Jump//	Addressing mode:	absolute//	Flags affected:	none//	Bytes/Cycles		3/3//unsigned long CPUOP_4C_JMP(void){	unsigned short	address;			address = CPUEA_Absolute();	PC = (unsigned short)address;		#if	COUNT_OPS	thr++;	#endif		return 3;}////	$4D EOR - Exclusive-OR Accumulator with Memory//	Addressing mode:	absolute//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_4D_EOR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = (unsigned char)MEMREADBYTE(address);	EOR(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$4E LSR - Logical Shift Memory Right//	Addressing mode:	absolute//	Flags affected:	n, z, c//	Bytes/Cycles		3/6//unsigned long CPUOP_4E_LSR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = (unsigned char)MEMREADBYTE(address);	temp = LSR(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 6;}////	$4F LSE - LSR then EOR (Quasi-Opcode)//	Addressing mode:	absolute//	Flags affected:	n, z, c//	Bytes/Cycles		3/6//unsigned long CPUOP_4F_LSE(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = (unsigned char)MEMREADBYTE(address);	temp = LSR(temp);	MEMWRITEBYTE(address,temp);	EOR(temp);	#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 6;}////	$50 BVC - Branch If Overflow Clear//	Addressing mode:	relative//	Flags affected:	none//	Bytes/Cycles		2/2//unsigned long CPUOP_50_BVC(void){	unsigned long	address;	char	temp;			address = CPUEA_Immediate();	PC += 1;		if (!TESTFLAGV())	{		temp = MEMREADBYTE(address);		PC += temp;	}		#if	COUNT_OPS	two++;	#endif		return 2;}////	$51 EOR - Exclusive-OR Accumulator with Memory//	Addressing mode:	zero page indirect indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		2/5//unsigned long CPUOP_51_EOR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndirectIndexedY();	temp = MEMREADBYTE(address);	EOR(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$55 EOR - Exclusive-OR Accumulator with Memory//	Addressing mode:	zero page indexed, X//	Flags affected:	n, z//	Bytes/Cycles		2/4//unsigned long CPUOP_55_EOR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	EOR(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$56 LSR - Logical Shift Memory Right//	Addressing mode:	zero page index, X//	Flags affected:	n, z, c//	Bytes/Cycles		2/6//unsigned long CPUOP_56_LSR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	temp = LSR(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$57 LSE - LSR then EOR  (Quasi-Opcode)//	Addressing mode:	zero page index, X//	Flags affected:	n, z, c//	Bytes/Cycles		2/6//unsigned long CPUOP_57_LSE(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	temp = LSR(temp);	MEMWRITEBYTE(address,temp);	EOR(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$58 CLI - Clear Interrupt Disable Flag//	Addressing mode:	implied//	Flags affected:	i//	Bytes/Cycles		1/2//unsigned long CPUOP_58_CLI(void){	CLEARFLAGI();	CPUCheckForLatchedInterrupts();		#if	COUNT_OPS	one++;	#endif		return 2;}////	$59 EOR - Exclusive-OR Accumulator with Memory//	Addressing mode:	absolute indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_59_EOR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteY();	temp = MEMREADBYTE(address);	EOR(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$5D EOR - Exclusive-OR Accumulator with Memory//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_5D_EOR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	EOR(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$5E LSR - Logical Shift Memory Right//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z, c//	Bytes/Cycles		3/7//unsigned long CPUOP_5E_LSR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = (unsigned char)MEMREADBYTE(address);	temp = LSR(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 7;}////	$60 RTS - Return from Subroutine//	Addressing mode:	implied//	Flags affected:	none//	Bytes/Cycles		1/6//unsigned long CPUOP_60_RTS(void){	unsigned short	address;			address = POPWORD();	PC = (unsigned short)(address+1);		#if	COUNT_OPS	one++;	#endif		return 6;}////	$61 ADC - Add With Carry//	Addressing mode:	zero page indexed indirect, X//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/6//unsigned long CPUOP_61_ADC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndexedIndirectX();	temp = MEMREADBYTE(address);	ADC(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$65 ADC - Add With Carry//	Addressing mode:	zero page//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/3//unsigned long CPUOP_65_ADC(void){	unsigned long	address;	unsigned long	temp;	unsigned long	carryin;	unsigned long	src;			address = CPUEA_ZeroPage();	temp = (unsigned char)MEMREADBYTE(address);	ADC(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$66 ROR - Rotate Memory Right//	Addressing mode:	zero page//	Flags affected:	n, z, c//	Bytes/Cycles		2/5//unsigned long CPUOP_66_ROR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	temp = ROR(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$67 LSE - LSR then EOR  (Quasi-Opcode)//	Addressing mode:	zero page//	Flags affected:	n, z, c//	Bytes/Cycles		2/6//unsigned long CPUOP_67_LSE(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	temp = LSR(temp);	MEMWRITEBYTE(address,temp);	EOR(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$68 PLA - Pull Accumulator (from stack)//	Addressing mode:	implied//	Flags affected:	n, z//	Bytes/Cycles		1/4//unsigned long CPUOP_68_PLA(void){	unsigned long	temp;			temp = POPBYTE();		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 4;}////	$69 ADC - Add With Carry//	Addressing mode:	immediate//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/2//unsigned long CPUOP_69_ADC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Immediate();	temp = MEMREADBYTE(address);	ADC(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$6A ROR - Rotate Memory Right//	Addressing mode:	accumulator//	Flags affected:	n, z, c//	Bytes/Cycles		1/2//unsigned long CPUOP_6A_ROR(void){	unsigned long	temp;			temp = ACC;	temp = ROR(temp);	ACC = temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$6C JMP - Jump//	Addressing mode:	absolute indirect//	Flags affected:	none//	Bytes/Cycles		3/5//unsigned long CPUOP_6C_JMP(void){	unsigned short	address;			address = CPUEA_AbsoluteIndirect();	PC = (unsigned short)address;		#if	COUNT_OPS	thr++;	#endif		return 5;}////	$6D ADC - Add With Carry//	Addressing mode:	absolute//	Flags affected:	n, v, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_6D_ADC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = (unsigned char)MEMREADBYTE(address);	ADC(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$6E ROR - Rotate Memory Right//	Addressing mode:	absolute//	Flags affected:	n, z, c//	Bytes/Cycles		3/6//unsigned long CPUOP_6E_ROR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	temp = ROR(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 6;}////	$70 BVS - Branch If Overflow Set//	Addressing mode:	relative//	Flags affected:	none//	Bytes/Cycles		2/2//unsigned long CPUOP_70_BVS(void){	unsigned long	address;	char	temp;			address = CPUEA_Immediate();	PC += 1;		if (TESTFLAGV())	{		temp = MEMREADBYTE(address);		PC += temp;	}		#if	COUNT_OPS	two++;	#endif		return 2;}////	$71 ADC - Add With Carry//	Addressing mode:	zero page indirect indexed, Y//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/5//unsigned long CPUOP_71_ADC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndirectIndexedY();	temp = MEMREADBYTE(address);	ADC(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$75 ADC - Add With Carry//	Addressing mode:	zero page indexed, X//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/4//unsigned long CPUOP_75_ADC(void){	unsigned long	address;	unsigned long	temp;	unsigned long	carryin;	unsigned long	src;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	ADC(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$76 ROR - Rotate Memory Right//	Addressing mode:	zero page index, X//	Flags affected:	n, z, c//	Bytes/Cycles		2/6//unsigned long CPUOP_76_ROR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	temp = ROR(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$78 SEI - Set Interrupt Disable Flag//	Addressing mode:	implied//	Flags affected:	i//	Bytes/Cycles		1/2//unsigned long CPUOP_78_SEI(void){	#if	COUNT_OPS	one++;	#endif		SETFLAGI();	return 2;}////	$79 ADC - Add With Carry//	Addressing mode:	absolute indexed, Y//	Flags affected:	n, v, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_79_ADC(void){	unsigned long	address;	unsigned long	temp;	unsigned long	carryin;	unsigned long	src;			address = CPUEA_AbsoluteY();	temp = MEMREADBYTE(address);	ADC(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$7D ADC - Add With Carry//	Addressing mode:	absolute indexed, X//	Flags affected:	n, v, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_7D_ADC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = (unsigned char)MEMREADBYTE(address);	ADC(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	7E ROR - Rotate Memory Right//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z, c//	Bytes/Cycles		3/7//unsigned long CPUOP_7E_ROR(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	temp = ROR(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 6;}////	$80 NOP - No Operation//	Addressing mode:	immediate//	Flags affected:	none//	Bytes/Cycles		2/2//unsigned long CPUOP_80_NOP(void){	#if	COUNT_OPS	thr++;	#endif		PC += 1;	return 2;}////	$81 STA - Store Accumulator to Memory//	Addressing mode:	zero page indexed indirect, X//	Flags affected:	none//	Bytes/Cycles		2/6//unsigned long CPUOP_81_STA(void){	unsigned long	address;			address = CPUEA_ZeroPageIndexedIndirectX();	MEMWRITEBYTE(address,ACC);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$84 STY - Store Index Register Y to Memory//	Addressing mode:	zero page//	Flags affected:	none//	Bytes/Cycles		2/3//unsigned long CPUOP_84_STY(void){	unsigned long	address;			address = CPUEA_ZeroPage();	MEMWRITEBYTE(address,INDY);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$85 STA - Store Accumulator to Memory//	Addressing mode:	zero page//	Flags affected:	none//	Bytes/Cycles		2/3//unsigned long CPUOP_85_STA(void){	unsigned long	address;			address = CPUEA_ZeroPage();	MEMWRITEBYTE(address,ACC);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$86 STX - Store Index Register X to Memory//	Addressing mode:	zero page//	Flags affected:	none//	Bytes/Cycles		2/3//unsigned long CPUOP_86_STX(void){	unsigned long	address;			address = CPUEA_ZeroPage();	MEMWRITEBYTE(address,INDX);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$87 AXS - Store Accumulator and X to Memory (Quasi Opcode)//	Addressing mode:	zero page//	Flags affected:	none//	Bytes/Cycles		2/3//unsigned long CPUOP_87_AXS(void){	unsigned long	address;	unsigned	long	temp;			address = CPUEA_ZeroPage();	temp  = ACC & INDX;	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$88 DEY - Decrement Index Register Y//	Addressing mode:	implied//	Flags affected:	n, z//	Bytes/Cycles		1/2//unsigned long CPUOP_88_DEY(void){	unsigned long	temp;			temp = INDY-1;		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDY = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$8A TXA - Transfer Index Register X to Accumulator//	Addressing mode:	implied//	Flags affected:	n, z//	Bytes/Cycles		1/2//unsigned long CPUOP_8A_TXA(void){	unsigned long	temp;			temp = INDX;		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$8C STY - Store Index Register Y to Memory//	Addressing mode:	absolute//	Flags affected:	none//	Bytes/Cycles		3/4//unsigned long CPUOP_8C_STY(void){	unsigned long	address;			address = CPUEA_Absolute();	MEMWRITEBYTE(address,INDY);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$8D STA - Store Accumulator to Memory//	Addressing mode:	absolute//	Flags affected:	none//	Bytes/Cycles		3/4//unsigned long CPUOP_8D_STA(void){	unsigned long	address;			address = CPUEA_Absolute();	MEMWRITEBYTE(address,ACC);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$8E STX - Store Index Register X to Memory//	Addressing mode:	absolute//	Flags affected:	none//	Bytes/Cycles		3/4//unsigned long CPUOP_8E_STX(void){	unsigned long	address;			address = CPUEA_Absolute();	MEMWRITEBYTE(address,INDX);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$8F SAX - Store Index Register X and A to Memory//	Addressing mode:	absolute//	Flags affected:	none//	Bytes/Cycles		3/4//unsigned long CPUOP_8F_SAX(void){	unsigned long	address;	address = CPUEA_Absolute();	MEMWRITEBYTE(address,INDX & ACC);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$90 BCC - Branch If Carry Clear//	Addressing mode:	relative//	Flags affected:	none//	Bytes/Cycles		2/2//unsigned long CPUOP_90_BCC(void){	unsigned long	address;	char	offset;			address = CPUEA_Immediate();	PC += 1;		if (!TESTFLAGC())	{		offset = MEMREADBYTE(address);		PC += offset;	}		#if	COUNT_OPS	two++;	#endif		return 2;}////	$91 STA - Store Accumulator to Memory//	Addressing mode:	zero page indirect indexed, Y//	Flags affected:	none//	Bytes/Cycles		2/6//unsigned long CPUOP_91_STA(void){	unsigned long	address;			address = CPUEA_ZeroPageIndirectIndexedY();	MEMWRITEBYTE(address,ACC);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$94 STY - Store Index Register Y to Memory//	Addressing mode:	zero page indexed, X//	Flags affected:	none//	Bytes/Cycles		2/4//unsigned long CPUOP_94_STY(void){	unsigned long	address;				address = CPUEA_ZeroPageX();	MEMWRITEBYTE(address,INDY);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$95 STA - Store Accumulator to Memory//	Addressing mode:	zero page indexed, X//	Flags affected:	none//	Bytes/Cycles		2/4//unsigned long CPUOP_95_STA(void){	unsigned long	address;				address = CPUEA_ZeroPageX();	MEMWRITEBYTE(address,ACC);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$96 STX - Store Index Register X to Memory//	Addressing mode:	zero page indexed, Y//	Flags affected:	none//	Bytes/Cycles		2/4//unsigned long CPUOP_96_STX(void){	unsigned long	address;				address = CPUEA_ZeroPageY();	MEMWRITEBYTE(address,INDX);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$97 AXS - Store Accumulator and X to Memory (Quasi Opcode)//	Addressing mode:	zero page indexed, Y//	Flags affected:	none//	Bytes/Cycles		2/4//unsigned long CPUOP_97_AXS(void){	unsigned long	address;	unsigned	long	temp;			address = CPUEA_ZeroPageY();	temp  = ACC & INDX;	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$98 TYA - Transfer Index Register Y to Accumulator//	Addressing mode:	implied//	Flags affected:	n, z//	Bytes/Cycles		1/2//unsigned long CPUOP_98_TYA(void){	unsigned long	temp;			temp = INDY;		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$99 STA - Store Accumulator to Memory//	Addressing mode:	absolute indexed, Y//	Flags affected:	none//	Bytes/Cycles		3/5//unsigned long CPUOP_99_STA(void){	unsigned long	address;			address = CPUEA_AbsoluteY();	MEMWRITEBYTE(address,ACC);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 5;}////	$9A TXS - Transfer Index Register X to Stack Pointer//	Addressing mode:	implied//	Flags affected:	none//	Bytes/Cycles		1/2//unsigned long CPUOP_9A_TXS(void){	#if	COUNT_OPS	one++;	#endif		STACK = INDX;	return 2;}////	$9D STA - Store Accumulator to Memory//	Addressing mode:	absolute indexed, X//	Flags affected:	none//	Bytes/Cycles		3/5//unsigned long CPUOP_9D_STA(void){	unsigned long	address;			address = CPUEA_AbsoluteX();	MEMWRITEBYTE(address,ACC);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 5;}////	$A0 LDY - Load Index Register Y from Memory//	Addressing mode:	immediate//	Flags affected:	n, z//	Bytes/Cycles		2/2//unsigned long CPUOP_A0_LDY(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Immediate();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDY = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$A1 LDA - Load Accumulator from Memory//	Addressing mode:	zero page indexed indirect, X//	Flags affected:	n, z//	Bytes/Cycles		2/6//unsigned long CPUOP_A1_LDA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndexedIndirectX();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$A2 LDX - Load Index Register X from Memory//	Addressing mode:	immediate//	Flags affected:	n, z//	Bytes/Cycles		2/2//unsigned long CPUOP_A2_LDX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Immediate();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDX = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$A4 LDY - Load Index Register Y from Memory//	Addressing mode:	zero page//	Flags affected:	n, z//	Bytes/Cycles		2/3//unsigned long CPUOP_A4_LDY(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDY = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$A5 LDA - Load Accumulator from Memory//	Addressing mode:	zero page//	Flags affected:	n, z//	Bytes/Cycles		2/3//unsigned long CPUOP_A5_LDA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$A6 LDX - Load Index Register X from Memory//	Addressing mode:	zero page//	Flags affected:	n, z//	Bytes/Cycles		2/3//unsigned long CPUOP_A6_LDX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDX = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$A7 LAX - Load Index Register X and A from Memory//	Addressing mode:	zero page//	Flags affected:	n, z//	Bytes/Cycles		2/3//unsigned long CPUOP_A7_LAX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = INDX = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$A8 TAY - Transfer Accumulator to Index Register Y//	Addressing mode:	implied//	Flags affected:	n, z//	Bytes/Cycles		1/2//unsigned long CPUOP_A8_TAY(void){	unsigned long	temp;			temp = ACC;		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDY = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$A9 LDA - Load Accumulator from Memory//	Addressing mode:	immediate//	Flags affected:	n, z//	Bytes/Cycles		2/2//unsigned long CPUOP_A9_LDA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Immediate();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$AA TAX - Transfer Accumulator to Index Register X//	Addressing mode:	implied//	Flags affected:	n, z//	Bytes/Cycles		1/2//unsigned long CPUOP_AA_TAX(void){	unsigned long	temp;			temp = ACC;		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDX = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$AB OAL - quasi opcode//	Addressing mode:	immediate//	Flags affected:	n, z//	Bytes/Cycles		2/2//unsigned long CPUOP_AB_OAL(void){	unsigned long	address;	unsigned long	temp;		//	//	NO CLUE!	//	temp = MEMREADBYTE(0xEE);	ORA(temp);	address = CPUEA_Immediate();	temp = MEMREADBYTE(address);	AND(temp);	INDX=ACC;	#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$AC LDY - Load Index Register Y from Memory//	Addressing mode:	absolute//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_AC_LDY(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDY = (unsigned char)temp;		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$AD LDA - Load Accumulator from Memory//	Addressing mode:	absolute//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_AD_LDA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$AE LDX - Load Index Register X from Memory//	Addressing mode:	absolute//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_AE_LDX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDX = (unsigned char)temp;		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$AF LAX - Load Index Register X and A from Memory//	Addressing mode:	absolute//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_AF_LAX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = INDX = (unsigned char)temp;			#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$B0 BCS - Branch If Carry Set//	Addressing mode:	relative//	Flags affected:	none//	Bytes/Cycles		2/2//unsigned long CPUOP_B0_BCS(void){	unsigned long	address;	char	offset;			address = CPUEA_Immediate();	PC += 1;		if (TESTFLAGC())	{		offset = MEMREADBYTE(address);		PC += offset;	}		#if	COUNT_OPS	two++;	#endif		return 2;}////	$B1 LDA - Load Accumulator from Memory//	Addressing mode:	zero page indirect indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		2/5//unsigned long CPUOP_B1_LDA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndirectIndexedY();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}//	//	$B3 LAX - Load Accumulator and Index Register X from Memory (Quasi-Opcode)//	Addressing mode:	zero page indirect indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		2/5//unsigned long CPUOP_B3_LAX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndirectIndexedY();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;	INDX = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$B4 LDY - Load Index Register Y from Memory//	Addressing mode:	zero page indexed, X//	Flags affected:	n, z//	Bytes/Cycles		2/4//unsigned long CPUOP_B4_LDY(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDY = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$B5 LDA - Load Accumulator from Memory//	Addressing mode:	zero page indexed, X//	Flags affected:	n, z//	Bytes/Cycles		2/4//unsigned long CPUOP_B5_LDA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$B6 LDX - Load Index Register X from Memory//	Addressing mode:	zero page indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		2/4//unsigned long CPUOP_B6_LDX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageY();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDX = temp;		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$B8 CLV - Clear Overflow Flag//	Addressing mode:	implied//	Flags affected:	v//	Bytes/Cycles		1/2//unsigned long CPUOP_B8_CLV(void){	#if	COUNT_OPS	one++;	#endif		CLEARFLAGV();	return 2;}////	$B9 LDA - Load Accumulator from Memory//	Addressing mode:	absolute indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_B9_LDA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteY();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$BA TSX - Transer Stack Pointer to Index Register X//	Addressing mode:	implied//	Flags affected:	n, z//	Bytes/Cycles		1/2//unsigned long CPUOP_BA_TSX(void){	unsigned long	temp;			temp = STACK;		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDX = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$BC LDY - Load Index Register Y from Memory//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_BC_LDY(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDY = (unsigned char)temp;		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$BD LDA - Load Accumulator from Memory//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_BD_LDA(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = (unsigned char)temp;		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$BE LDX - Load Index Register X from Memory//	Addressing mode:	absolute indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_BE_LDX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteY();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDX = (unsigned char)temp;		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$BF LAX - Load Index Register X and A from Memory//	Addressing mode:	absolute indexed, Y//	Flags affected:	n, z//	Bytes/Cycles		3/4//unsigned long CPUOP_BF_LAX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteY();	temp = MEMREADBYTE(address);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	ACC = INDX = (unsigned char)temp;	#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$C0 CPY - Compare Index Register Y with Memory//	Addressing mode:	immediate//	Flags affected:	n, z, c//	Bytes/Cycles		2/2//unsigned long CPUOP_C0_CPY(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Immediate();	temp = MEMREADBYTE(address);	CPY(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$C1 CMP - Compare Accumulator with Memory//	Addressing mode:	zero page indexed indirect, X//	Flags affected:	n, z, c//	Bytes/Cycles		2/6//unsigned long CPUOP_C1_CMP(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndexedIndirectX();	temp = MEMREADBYTE(address);	CMP(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$C3 DCM - DEC and Compare Accumulator with Memory (Quasi-Opcode)//	Addressing mode:	zero page indexed indirect, X//	Flags affected:	n, z, c//	Bytes/Cycles		2/8//unsigned long CPUOP_C3_DCM(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndexedIndirectX();	temp = MEMREADBYTE(address);	temp = DEC(temp);	MEMWRITEBYTE(address,temp);	CMP(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 8;}////	$C4 CPY - Compare Index Register Y with Memory//	Addressing mode:	zero page//	Flags affected:	n, z, c//	Bytes/Cycles		2/3//unsigned long CPUOP_C4_CPY(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	CPY(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$C5 CMP - Compare Accumulator with Memory//	Addressing mode:	zero page//	Flags affected:	n, z, c//	Bytes/Cycles		2/3//unsigned long CPUOP_C5_CMP(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	CMP(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$C6 DEC - Decrement//	Addressing mode:	zero page//	Flags affected:	n, z//	Bytes/Cycles		2/5//unsigned long CPUOP_C6_DEC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	temp = DEC(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$C7 DCM - DEC and Compare Accumulator with Memory (Quasi-Opcode)//	Addressing mode:	zero page//	Flags affected:	n, z, c//	Bytes/Cycles		2/5//unsigned long CPUOP_C7_DCM(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	temp = DEC(temp);	MEMWRITEBYTE(address,temp);	CMP(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$C8 INY - Increment Index Register Y//	Addressing mode:	implied//	Flags affected:	n, z//	Bytes/Cycles		1/2//unsigned long CPUOP_C8_INY(void){	unsigned long	temp;			temp = INDY+1;		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDY = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$C9 CMP - Compare Accumulator with Memory//	Addressing mode:	immediate//	Flags affected:	n, z, c//	Bytes/Cycles		2/2//unsigned long CPUOP_C9_CMP(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Immediate();	temp = MEMREADBYTE(address);	CMP(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$CA DEX - Decrement Index Register X//	Addressing mode:	implied//	Flags affected:	n, z//	Bytes/Cycles		1/2//unsigned long CPUOP_CA_DEX(void){	unsigned long	temp;			temp = (unsigned char)(INDX-1);		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDX = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$CC CPY - Compare Index Register Y with Memory//	Addressing mode:	absolute//	Flags affected:	n, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_CC_CPY(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	CPY(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$CD CMP - Compare Accumulator with Memory//	Addressing mode:	absolute//	Flags affected:	n, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_CD_CMP(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	CMP(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 2;}////	$CE DEC - Decrement//	Addressing mode:	absolute//	Flags affected:	n, z//	Bytes/Cycles		3/6//unsigned long CPUOP_CE_DEC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	temp = DEC(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 6;}////	$D0 BNE - Branch If Not Equal//	Addressing mode:	relative//	Flags affected:	none//	Bytes/Cycles		2/2//unsigned long CPUOP_D0_BNE(void){	unsigned long	address;	char	temp;			if (!TESTFLAGZ())	{		address = CPUEA_Immediate();		temp = MEMREADBYTE(address);		PC += temp;	}		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$D1 CMP - Compare Accumulator with Memory//	Addressing mode:	zero page indirect indexed, Y//	Flags affected:	n, z, c//	Bytes/Cycles		2/5//unsigned long CPUOP_D1_CMP(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndirectIndexedY();	temp = MEMREADBYTE(address);	CMP(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$D5 CMP - Compare Accumulator with Memory//	Addressing mode:	zero page indexed, X//	Flags affected:	n, z, c//	Bytes/Cycles		2/4//unsigned long CPUOP_D5_CMP(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	CMP(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$D6 DEC - Decrement//	Addressing mode:	zero page indexed, X//	Flags affected:	n, z//	Bytes/Cycles		2/6//unsigned long CPUOP_D6_DEC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	temp = DEC(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$D8 CLD - Clear Decimal Mode Flag//	Addressing mode:	implied//	Flags affected:	d//	Bytes/Cycles		1/2//unsigned long CPUOP_D8_CLD(void){#if	DEBUG	if (gVerbose)		debug_window_printf("decimal mode off");#endif		#if	COUNT_OPS	one++;	#endif		CLEARFLAGD();	return 2;}////	$D9 CMP - Compare Accumulator with Memory//	Addressing mode:	absolute indexed, Y//	Flags affected:	n, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_D9_CMP(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteY();	temp = MEMREADBYTE(address);	CMP(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$DD CMP - Compare Accumulator from Memory//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_DD_CMP(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	CMP(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$DE DEC - Decrement//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z//	Bytes/Cycles		3/7//unsigned long CPUOP_DE_DEC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	temp = DEC(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 7;}////	$E0 CPX - Compare Index Register X with Memory//	Addressing mode:	immediate//	Flags affected:	n, z, c//	Bytes/Cycles		2/2//unsigned long CPUOP_E0_CPX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Immediate();	temp = MEMREADBYTE(address);	CPX(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$E1 SBC - Subtract With Carry//	Addressing mode:	zero page indexed indirect, X//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/6//unsigned long CPUOP_E1_SBC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndexedIndirectX();	temp = MEMREADBYTE(address);	SBC(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$E4 CPX - Compare Index Register X with Memory//	Addressing mode:	zero page//	Flags affected:	n, z, c//	Bytes/Cycles		2/3//unsigned long CPUOP_E4_CPX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	CPX(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$E5 SBC - Subtract With Carry//	Addressing mode:	zero page//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/3//unsigned long CPUOP_E5_SBC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	SBC(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 3;}////	$E6 INC - Increment//	Addressing mode:	zero page//	Flags affected:	n, z//	Bytes/Cycles		2/5//unsigned long CPUOP_E6_INC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	temp = INC(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$E7 INS - Increment and Subtract with Carry (Quasi-Opcode)//	Addressing mode:	zero page//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/5//unsigned long CPUOP_E7_INS(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPage();	temp = MEMREADBYTE(address);	temp=INC(temp);	SBC(temp);	//inc then subtract	MEMWRITEBYTE(address,temp);	//not sure..		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$E8 INX - Increment Index Register X//	Addressing mode:	implied//	Flags affected:	n, z//	Bytes/Cycles		1/2//unsigned long CPUOP_E8_INX(void){	unsigned long	temp;			temp = INDX+1;		CLEARFLAGNZ();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	INDX = (unsigned char)temp;		#if	COUNT_OPS	one++;	#endif		return 2;}////	$E9 SBC - Subtract With Carry//	Addressing mode:	immediate//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/2//unsigned long CPUOP_E9_SBC(void){	unsigned long	address;	unsigned long	temp;	unsigned long	carryin;	unsigned long	src;			address = CPUEA_Immediate();	temp = MEMREADBYTE(address);	SBC(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 2;}////	$EA NOP - No Operation//	Addressing mode:	implied//	Flags affected:	none//	Bytes/Cycles		1/2//unsigned long CPUOP_EA_NOP(void){	return 2;}////	$EC CPX - Compare Index Register X with Memory//	Addressing mode:	absolute//	Flags affected:	n, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_EC_CPX(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	CPX(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$ED SBC - Subtract With Carry//	Addressing mode:	absolute//	Flags affected:	n, v, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_ED_SBC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	SBC(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$EE INC - Increment//	Addressing mode:	absolute//	Flags affected:	n, z//	Bytes/Cycles		3/6//unsigned long CPUOP_EE_INC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_Absolute();	temp = MEMREADBYTE(address);	temp = INC(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 6;}////	$F0 BEQ - Branch If Equal//	Addressing mode:	relative//	Flags affected:	none//	Bytes/Cycles		2/2//unsigned long CPUOP_F0_BEQ(void){	unsigned long	address;	char	temp;			address = CPUEA_Immediate();	PC += 1;		if (TESTFLAGZ())	{		temp = MEMREADBYTE(address);		PC += temp;	}		#if	COUNT_OPS	two++;	#endif		return 2;}////	$F1 SBC - Subtract With Carry//	Addressing mode:	zero page indirect indexed, Y//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/5//unsigned long CPUOP_F1_SBC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndirectIndexedY();	temp = MEMREADBYTE(address);	SBC(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 5;}////	$F3 INS - Increment and Subtract with Carry (Quasi-Opcode)//	Addressing mode:	zero page indirect indexed, Y//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/8//unsigned long CPUOP_F3_INS(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageIndirectIndexedY();	temp = MEMREADBYTE(address);	temp=INC(temp);	SBC(temp);	//inc then subtract	MEMWRITEBYTE(address,temp);	//not sure..		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 8;}////	$F5 SBC - Subtract With Carry//	Addressing mode:	zero page indexed, X//	Flags affected:	n, v, z, c//	Bytes/Cycles		2/4//unsigned long CPUOP_F5_SBC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	SBC(temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 4;}////	$F6 INC - Increment//	Addressing mode:	zero page indexed, X//	Flags affected:	n, z//	Bytes/Cycles		2/6//unsigned long CPUOP_F6_INC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_ZeroPageX();	temp = MEMREADBYTE(address);	temp = INC(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	two++;	#endif		PC += 1;	return 6;}////	$F8 SED - Set Decimal Mode Flag//	Addressing mode:	implied//	Flags affected:	d//	Bytes/Cycles		1/2//unsigned long CPUOP_F8_SED(void){#if	DEBUG	if (gVerbose)		debug_window_printf("decimal mode on");#endif		#if	COUNT_OPS	one++;	#endif		SETFLAGD();	return 2;}////	$F9 SBC - Subtract With Carry//	Addressing mode:	absolute indexed, Y//	Flags affected:	n, v, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_F9_SBC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteY();	temp = MEMREADBYTE(address);	SBC(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$FA NOP - No Operation//	Addressing mode:	implied//	Flags affected:	none//	Bytes/Cycles		1/2//unsigned long CPUOP_FA_NOP(void){	#if	COUNT_OPS	thr++;	#endif			return 2;}////	$FC NOP - No Operation//	Addressing mode:	absolute indexed, X//	Flags affected:	none//	Bytes/Cycles		3/4//unsigned long CPUOP_FC_NOP(void){	#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$FD SBC - Subtract With Carry//	Addressing mode:	absolute indexed, X//	Flags affected:	n, v, z, c//	Bytes/Cycles		3/4//unsigned long CPUOP_FD_SBC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	SBC(temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 4;}////	$FE INC - Increment//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z//	Bytes/Cycles		3/7//unsigned long CPUOP_FE_INC(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	temp = INC(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 7;}////	$FF INS - Increment and Subtract with Carry (Quasi-Opcode)//	Addressing mode:	absolute indexed, X//	Flags affected:	n, z//	Bytes/Cycles		3/7//unsigned long CPUOP_FF_INS(void){	unsigned long	address;	unsigned long	temp;			address = CPUEA_AbsoluteX();	temp = MEMREADBYTE(address);	temp = INC(temp);	SBC(temp);	MEMWRITEBYTE(address,temp);		#if	COUNT_OPS	thr++;	#endif		PC += 2;	return 7;}unsigned long ASMCPUOP_FF_TRP(void);unsigned long ASMCPUOP_FF_TRP(void){	ACC = gACCRegister;	INDX = gINXRegister;	INDY = gINYRegister;	STACK = gSTACKRegister;	PC = gPCRegister;	FLAGS = gSRRegister;		TrapExecute(PC);		gACCRegister = ACC;	gINXRegister = INDX;	gINYRegister = INDY;	gSTACKRegister = STACK;	gPCRegister = PC;	gSRRegister = FLAGS;		return 5;}unsigned long CPUOP_FF_TRP(void){	TrapExecute(PC);	return 5;}//// ADC - Add With Carry//void ADC(unsigned long value){	unsigned long	carryin;	unsigned long	temp;			if (TESTFLAGD())	{	//	CPUOP_UnimplementedOP();	debug_window_printf("Should Have Used Decimal");	//	return;	}		carryin = TESTFLAGC() ? 1 : 0;	temp = ACC + value + carryin;		CLEARFLAGNVZC();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	if (temp&0x100) SETFLAGC();	if (!((ACC ^ value) & 0x80) && ((ACC ^ temp) & 0x80)) SETFLAGV();	ACC = (unsigned char)temp;}//// AND - And Accumulator with Memory//void AND(unsigned long value){	ACC &= value;		CLEARFLAGNZ();	if (ACC & BITN) SETFLAGN();	if (!(ACC & 0xFF)) SETFLAGZ();}////	ASL - Shift Memory or Accumulator Left//unsigned long ASL(unsigned long value){	value <<= 1;		CLEARFLAGNZC();	if (value & 0x100) SETFLAGC();	if (value & BITN) SETFLAGN();	if (!(value & 0xFF)) SETFLAGZ();		return (unsigned char)value;}//// BIT - Test Memory Bits against Accumulator//void BIT(unsigned long value){	CLEARFLAGNVZ();	if (value & BITN) SETFLAGN();	if (value & BITV) SETFLAGV();	if (!((value & 0xFF) & (ACC & 0xFF))) SETFLAGZ();}////	CMP - Compare Accumulator with Memory//void CMP(unsigned long value){	unsigned long	temp;			temp = ACC - value;		CLEARFLAGNZC();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	if (ACC >= value) SETFLAGC();}////	CPY - Compare Index Register Y with Memory//void CPY(unsigned long value){	unsigned long	temp;			temp = INDY - value;		CLEARFLAGNZC();	if (temp & 0x80) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	if (INDY >= value) SETFLAGC();}//// CPX - Compare Index Register X with Memory//void CPX(unsigned long value){	unsigned long	temp;			temp = INDX - value;		CLEARFLAGNZC();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	if (INDX >= value) SETFLAGC();}////	DEC - Decrement//unsigned long DEC(unsigned long value){	value = (unsigned char)(value-1);		CLEARFLAGNZ();	if (value & BITN) SETFLAGN();	if (!(value & 0xFF)) SETFLAGZ();		return value;}////	EOR - Exclusive-OR Accumulator with Memory//void EOR(unsigned long value){	ACC ^= value;		CLEARFLAGNZ();	if (ACC & BITN) SETFLAGN();	if (!(ACC & 0xFF)) SETFLAGZ();}//// INC - Increment//unsigned long INC(unsigned long value){	value = (unsigned char)(value+1);		CLEARFLAGNZ();	if (value & BITN) SETFLAGN();	if (!(value & 0xFF)) SETFLAGZ();		return value;}////	LSR - Logical Shift Memory Right//unsigned long LSR(unsigned long value){	CLEARFLAGNZC();	if (value & 0x01) SETFLAGC();	value >>= 1;	if (!(value & 0xFF)) SETFLAGZ();		return (unsigned char)value;}////	ORA - OR Accumulator with Memory//void ORA(unsigned long value){	ACC |= value;		CLEARFLAGNZ();	if (ACC & BITN) SETFLAGN();	if (!(ACC & 0xFF)) SETFLAGZ();}////	ROL - Rotate Memory or Accumulator Left//unsigned long ROL(unsigned long value){	value <<= 1;	if (TESTFLAGC())		value |= 0x01;		CLEARFLAGNZC();	if (value & 0x100) SETFLAGC();	if (value & BITN) SETFLAGN();	if (!(value & 0xFF)) SETFLAGZ();		return (unsigned char)value;}//// ROR - Rotate Memory or Accumulator Right//unsigned long ROR(unsigned long value){	if (TESTFLAGC())		value |= 0x100;		CLEARFLAGNZC();	if (value & 0x01)		SETFLAGC();	value >>= 1;		if (value & BITN) SETFLAGN();	if (!(value & 0xFF)) SETFLAGZ();		return value;}////	SBC - Subtract With Carry//void SBC(unsigned long value){	unsigned long	temp;	unsigned long	carryin;			if (TESTFLAGD())	{	//	CPUOP_UnimplementedOP();	debug_window_printf("Should Have Used Decimal");	//	return;	}		carryin = TESTFLAGC() ? 0 : 1;	temp = ACC - value - carryin;		CLEARFLAGNVZC();	if (temp & BITN) SETFLAGN();	if (!(temp & 0xFF)) SETFLAGZ();	if (!(temp & 0x100)) SETFLAGC();	if (((ACC ^ value) & 0x80) && ((ACC ^ temp) & 0x80)) SETFLAGV();	ACC = (unsigned char)temp;}