/*-------------------------------------------------------------------------------*\||	File:	RasterBitmapSmoothwSpr8bit.c||	Description:||||||	Copyright ï¿½	1994, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include		"ColorDrawing.h"#include 	"Drawing.h"#include		"DrawingGlobals.h"#include		"VICSprites.h"extern	short			gSpriteOnRaster[256];extern	unsigned	char	gHorizScroll;extern	unsigned	char	gVerticalScroll;extern	unsigned	char	gVICReg[];void	RasterLine_MultiColorBitmap_Sprite_38Char(short	rl){			SInt32					rasterline=rl;register	UInt32		i;register	unsigned short		*dstImageSmaller;			UInt32		*borders;			unsigned	char		*cfuckingsucks;register	unsigned char		*VideoCharacterByte;register	unsigned char		*screenData;register	unsigned char		*curColorLine;//register	UInt32		*cachegandbackcolor=gAndBackColor;            fprintf(stderr,"RasterLine_MultiColorBitmap_Sprite_38Char %d\n",rl);    //Debugger();if (gVICReg[0x11]&0x08)	{	}else	{		if (rasterline<8 && gVerticalScroll==0)			{			RasterLine_Border_8Bit(rasterline);			return;			}		rasterline-=(gVerticalScroll);		if (rasterline < 0)			{			RasterLine_Border_8Bit(rasterline+(gVerticalScroll));			return;			}	}{register	UInt32				rasterbasedoffset=gRasterBasedOffset[rasterline];VideoCharacterByte=gVideoCharacterBase+(rasterline&0x07); //same as (rasterline %8)curColorLine=gVideoColorBase+rasterbasedoffset;screenData=gVideoScreenRamBase+rasterbasedoffset;	if (gVICReg[0x11]&0x08)	{	dstImageSmaller=(unsigned short *)gTheActiveBitsArray[rasterline];	borders=(UInt32 *)dstImageSmaller;	cfuckingsucks=(unsigned char *)dstImageSmaller;	}else	{	dstImageSmaller=(unsigned short *)gTheActiveBitsArray[rasterline+gVerticalScroll];	borders=(UInt32 *)dstImageSmaller;	cfuckingsucks=(unsigned char *)dstImageSmaller;	}if (gVICReg[0x16]&0x08){}else{cfuckingsucks-=(7-gHorizScroll);dstImageSmaller=(unsigned short *)cfuckingsucks;}}////	each char in charrom is eight bytes. There are 40 accross on the screen.// take the rasterline / 8 multiply by 40 to find the character number that we should start on.//	/*VideoCharacterByte=gVideoCharacterBase+(rasterbasedoffset*8) + (rasterline&0x07);curColorLine=gVideoColorBase+rasterbasedoffset;screenData=gVideoScreenRamBase+ (rasterbasedoffset);dstImageSmaller=(unsigned short *)gTheActiveBitsArray[rasterline];*/////	draw border here//dstImageSmaller+=8;////	draw characters//	for (i=0;i<38;i++)		{		register	unsigned	char		bits=*VideoCharacterByte;			switch (bits>>4)			{			case	0:				*((UInt32 *)dstImageSmaller)=gAndBackColor[0];				dstImageSmaller+=2;			break;			case	1:				*(dstImageSmaller++)=*gAndBackColor;						*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];			break;			case	2:				*(dstImageSmaller++)=gAndBackColor[0];				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	3:				*(dstImageSmaller++)=gAndBackColor[0];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	4:				*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];				*(dstImageSmaller++)=gAndBackColor[0];			break;			case	5:				*((UInt32 *)dstImageSmaller)=eightBitTable[(*screenData)>>4];				dstImageSmaller+=2;			break;			case	6:				{				register	unsigned	long	temp=*screenData;					*(dstImageSmaller++)=eightBitTable[((temp)>>4)];				*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];					}			break;			case	7:				*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	8:				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];				*(dstImageSmaller++)=gAndBackColor[0];			break;			case	9:				{				register	unsigned	long	temp=*screenData;					*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];				*(dstImageSmaller++)=eightBitTable[((temp)>>4)];					}			break;			case	10:				*((UInt32 *)dstImageSmaller)=eightBitTable[((*screenData)&0x0F)];				dstImageSmaller+=2;			break;			case	11:				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	12:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=gAndBackColor[0];			break;			case	13:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];			break;			case	14:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	15:			*((unsigned long *)dstImageSmaller)=eightBitTable[*curColorLine];			dstImageSmaller+=2;			break;								}			switch (bits&0x0F)			{			case	0:				*((UInt32 *)dstImageSmaller)=gAndBackColor[0];				dstImageSmaller+=2;			break;			case	1:				*(dstImageSmaller++)=gAndBackColor[0];						*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];			break;			case	2:				*(dstImageSmaller++)=gAndBackColor[0];				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	3:				*(dstImageSmaller++)=gAndBackColor[0];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	4:				*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];				*(dstImageSmaller++)=gAndBackColor[0];			break;			case	5:				*((UInt32 *)dstImageSmaller)=eightBitTable[(*screenData)>>4];				dstImageSmaller+=2;			break;			case	6:				{				register	UInt32	temp=*screenData;					*(dstImageSmaller++)=eightBitTable[((temp)>>4)];				*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];					}			break;			case	7:				*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	8:				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];						*(dstImageSmaller++)=gAndBackColor[0];			break;			case	9:				{				register	UInt32	temp=*screenData;					*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];				*(dstImageSmaller++)=eightBitTable[((temp)>>4)];				}			break;			case	10:				*(UInt32 *)dstImageSmaller=eightBitTable[((*screenData)&0x0F)];				dstImageSmaller+=2;			break;			case	11:				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	12:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=gAndBackColor[0];			break;			case	13:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];			break;			case	14:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	15:				*((UInt32 *)dstImageSmaller)=eightBitTable[*curColorLine];				dstImageSmaller+=2;			break;								}		screenData++;	curColorLine++;	VideoCharacterByte+=8;		}		if (gSpriteOnRaster[rl+50])	SpriteDrawOneRaster(rl+50,gTheActiveBitsArray[rl]);		*(borders++)=gBorderColor;*(borders++)=gBorderColor;borders+=38*2;*(borders++)=gBorderColor;*(borders++)=gBorderColor;////	draw border here//}