/*-------------------------------------------------------------------------------*\||	File:	VIC.c||	Description:||||||	Copyright ©	1994, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include "DebugWindow.h"#include	"DrawingGlobals.h"#include "Drawing.h"#include	"VICInterrupts.h"#include	"VICSprites.h"#include "VIC.h"extern	RasteringFunction	gCurrentRasteringFunction;extern	unsigned	char	gSpriteToSpriteCollisions;#if	DEBUGextern	Boolean	gVerbose;#endif/*	local constants	*/#define	kVICBaseAddress	0xD000#define	LOCALDEBUG			0/*	local globals	*/unsigned char	gVICReg[64];UInt32	gCurrentRaster=0;unsigned	char	gVerticalScroll;unsigned	char	gHorizScroll;/*externs*/extern	UInt32	gRasterNumberToInterrupt;extern	Boolean	gUpdateBkgNormalRequest;extern	Boolean	gUpdateMultiColorRequest;extern	SpriteData	gSpriteInfo[8];//// From DoubleDrawingSetup.c//extern double	**DNormal_ColorTable;extern double	**DMulti_ColorTable;extern double	**gDoubleColorTable;extern  double	**DColorTables[16];#define	TURNSPRITESON	1////	Legend:	////	¥ - need to do something about these bits..//	Ã - have set flags, or called function to deal with bits//void VICWrite(unsigned long address,unsigned long value){	register	unsigned long	reg;	register	unsigned long	val;			val = value;	reg = (address-kVICBaseAddress)&0x3F;		switch(reg)	{		case 0x00:		//	Sprite 0 X Position		case 0x02:		//	Sprite 1 X Position		case 0x04:		//	Sprite 2 X Position		case 0x06:		//	Sprite 3 X Position		case 0x08:		//	Sprite 4 X Position		case 0x0A:		//	Sprite 5 X Position		case 0x0C:		//	Sprite 6 X Position		case 0x0E:		//	Sprite 7 X Position#if	TURNSPRITESON			{			unsigned	long	spriteNum=reg>>1;						gVICReg[reg] = val;			SpriteSetXPosition (spriteNum);			}#endif		break;		case 0x01:		//	Sprite 0 Y Position		case 0x03:		//	Sprite 1 Y Position		case 0x05:		//	Sprite 2 Y Position		case 0x07:		//	Sprite 3 Y Position		case 0x09:		//	Sprite 4 Y Position		case 0x0B:		//	Sprite 5 Y Position		case 0x0D:		//	Sprite 6 Y Position		case 0x0F:		//	Sprite 7 Y Position			{			unsigned	long	spriteNum=reg>>1;						gVICReg[reg] = val;			SpriteSetYPosition (spriteNum);			}				break;		case 0x10:		//	Sprite 0-7 X Position (MSB of X coordinate)#if	TURNSPRITESON			{			unsigned	long	spriteNum;			unsigned long	temp;						temp=gVICReg[reg]^val;			if (temp)				{				gVICReg[reg] = val;				for (spriteNum=0;spriteNum<8;spriteNum++)					if (1<<spriteNum & temp)						SpriteSetXPosition (spriteNum);				}			}#endif			break;		case 0x11:		//	VIC Control Register			{			unsigned long	temp;						temp=gVICReg[reg]^val;			gVICReg[reg] = val;							//Switch the values before going into change modes			if (temp&0x70)					{				//	Change Video Modes				VICChangeVideoModes();				}			if (temp&0x08)					{				//	Change Video Modes				//debug_window_printf("you suck");				}				gRasterNumberToInterrupt=(gRasterNumberToInterrupt&0xFF) | ((val&0x80)<<1);				gVerticalScroll=val&0x07;						/*						VIC Control Register							7	Raster Compare: (Bit 8)	See 53266						Ã							6	Extended Color Text Mode 1 = Enable						Ã							5	Bit Map Mode. 1 = Enable									Ã							4	Blank Screen to Border Color: O = Blank				Ã							3	Select 24/25 Row Text Display: 1 = 25 Rows			Ã							2-0	Smooth Scroll to Y Dot-Position (0-7)				¥						*/			}			break;		case 0x12:		//	Read/Write Raster Value for Compare IRQ			//gRasterNumberToInterrupt|=val&0xFF;	//Store the value into the low eight bits															//The eighth bit is set in register 0x11																			gRasterNumberToInterrupt=(gRasterNumberToInterrupt&0x100) | (val&0xFF);			break;		case 0x13:		//	Light-Pen Latch X Position		case 0x14:		//	Light-Pen Latch Y Position			break;		case 0x15:		//	Sprite Display Enable (1 = Enable)				gVICReg[reg] = val;				SpriteEnableDisable();			break;		case 0x16:		//	VIC Control Register			{			unsigned long	temp;						temp=gVICReg[reg]^val;			gVICReg[reg] = val;							//Switch the values before going into change modes			if (temp&0x10)	//change this to exclude bit three later maybe..				{				//	Change Video Modes				VICChangeVideoModes();				}			if (temp&0x08)	//change this to exclude bit three later maybe..				{				//	Change Video Modes				}						/*						VIC Control Register							7-6	Unused							5	ALWAYS SET THIS BIT TO 0 !							4	Multi-Color Mode: 1 = Enable (Text or Bit-Map) 		Ã							3	Select 38/40 Column Text Display: 1 = 40 Cols 		Ã							2-0	Smooth Scroll to X Pos									¥						*/				gHorizScroll=val&0x07 ;			}			break;		case 0x17:		//	Sprites 0-7 Expand 2x Vertical (Y)#if	TURNSPRITESON//this isn't used anymore...				{				unsigned	long	spriteNum;//				unsigned	long	temp;							//	temp=gVICReg[0x17]^val;				gVICReg[0x17] = val;				for (spriteNum=0;spriteNum<8;spriteNum++)			//		if (1<<spriteNum & temp)			//			{			//			gSpriteInfo[spriteNum].expandVert=val&(1<<spriteNum);						SpriteSetYPosition (spriteNum);			//			}					}#endif			break;		case 0x18:		//	VIC Memory Control Register					/*					VIC Memory Control Register						7-4	Video Matrix Base Address (inside VIC)				Ã						3-1	Character Dot-Data Base	Address (inside VIC)		Ã						0	Select upper/lower Character Set							Ã					*/					gVICReg[reg] = val;				CalculateVideoRamOffsets ();			break;		case 0x19:				VICWriteD019(val);			break;		case 0x1A:						VICWriteD01A(val);			break;		case 0x1B:		//	Sprite to Background Display Priority: 1 = Sprite#if	TURNSPRITESON				gVICReg[reg] = val;				SpriteSetBkgDisplayPriority ();#endif			break;		case 0x1C:		//	Sprite 0-7 Multi-Color Mode Select: 1 = MCM#if	TURNSPRITESON				{				short	spriteNum;								for (spriteNum=0;spriteNum<8;spriteNum++)					gSpriteInfo[spriteNum].multiColor=val&(1<<spriteNum);				}#endif			break;		case 0x1D:		//	Sprite 0-7 Expand 2x Horizontal (X)#if		TURNSPRITESON				{				short	spriteNum;								for (spriteNum=0;spriteNum<8;spriteNum++)					gSpriteInfo[spriteNum].expandHoriz=val&(0x01<<spriteNum);				}#endif			break;		case 0x1E:		//	Sprite to Sprite Collision Detect		case 0x1F:		//	Sprite to Background Collision Detect			break;		case 0x20:		//	Border Color				val&=0x0F;//truncate since we only have 16 colors		switch (gPixelDepth)			{			case	8:					gBorderColor=eightBitTable[val];				break;			case	4:					gBorderColor=fourBitTable[val];				break;			case	1:				break;			}			break;		case 0x21:		//	Background Color 0				val&=0x0F;//truncate since we only have 16 colors				gBackColorsUnconverted[0]=val;				gVICReg[0x21] = val;			switch (gPixelDepth)				{				case	8:					gAndBackColor[0]=eightBitTable[val];				break;				case	4:					gAndBackColor[0]=fourBitTable[val];							break;				case	1:				break;					}							//	This function needs to be called for:					//			RasterLine_MultiColorText_40Char					//			RasterLine_NormalText_40Char				//if (gUpdateBkgNormalRequest)				//	UpdateBackgroundColor_NormalText();				Normal_ColorTable=ColorTables[gVICReg[0x21]];				DNormal_ColorTable=DColorTables[gVICReg[0x21]];				if (!(gVICReg[0x16]&0x10))					{									gNastyColorTable=Normal_ColorTable;					gDoubleColorTable=DNormal_ColorTable;					}												if (gUpdateMultiColorRequest)					BuildMultiColorTable();			break;		case 0x22:		//	Background Color 1				val&=0x0F;//truncate since we only have 16 colors				gBackColorsUnconverted[1]=val;			switch (gPixelDepth)				{				case	8:					gAndBackColor[1]=eightBitTable[val];				break;				case	4:					gAndBackColor[1]=fourBitTable[val];							break;				case	1:				break;					}									if (gUpdateMultiColorRequest)					BuildMultiColorTable();			break;		case 0x23:		//	Background Color 2				val&=0x0F;//truncate since we only have 16 colors				gBackColorsUnconverted[2]=val;			switch (gPixelDepth)				{				case	8:					gAndBackColor[2]=eightBitTable[val];				break;				case	4:					gAndBackColor[2]=fourBitTable[val];							break;				case	1:				break;					}									if (gUpdateMultiColorRequest)					BuildMultiColorTable();			break;		case 0x24:		//	Background Color 3				val&=0x0F;//truncate since we only have 16 colors				gBackColorsUnconverted[3]=val;			switch (gPixelDepth)				{				case	8:					gAndBackColor[3]=eightBitTable[val];				break;				case	4:					gAndBackColor[3]=fourBitTable[val];							break;				case	1:				break;					}					break;		case 0x25:		//	Sprite Multi-Color Register 0				val&=0x0F;//truncate since we only have 16 colors			break;		case 0x26:		//	Sprite Multi-Color Register 1				val&=0x0F;//truncate since we only have 16 colors			break;			//check on sprite color truncation..		case 0x27:		//	Sprite 0 Color		case 0x28:		//	Sprite 1 Color		case 0x29:		//	Sprite 2 Color		case 0x2A:		//	Sprite 3 Color		case 0x2B:		//	Sprite 4 Color		case 0x2C:		//	Sprite 5 Color		case 0x2D:		//	Sprite 6 Color		case 0x2E:		//	Sprite 7 Color				val&=0x0F;//truncate since we only have 16 colors			break;		default:			break;	}		#if	LOCALDEBUG && DEBUG		if (reg!=0x20&& reg!=0x21)	//we don't care about no stinking border colors		if (gVerbose)			debug_window_printf("VICWrite: reg: %X, val: %X",(int)reg,(int)val);	#endif	gVICReg[reg] = val;}//#ifndef	powerc//unsigned long VICRead(unsigned long address:__A0)//#elseunsigned long VICRead(unsigned long address)//#endif{	register	unsigned long	reg;	register	unsigned long	val;			reg = (address-kVICBaseAddress)&0x3F;	val = gVICReg[reg];		switch(reg)	{/*		case 0x00:		//	Sprite 0 X Position		case 0x01:		//	Sprite 0 Y Position		case 0x02:		//	Sprite 1 X Position		case 0x03:		//	Sprite 1 Y Position		case 0x04:		//	Sprite 2 X Position		case 0x05:		//	Sprite 2 Y Position		case 0x06:		//	Sprite 3 X Position		case 0x07:		//	Sprite 3 Y Position		case 0x08:		//	Sprite 4 X Position		case 0x09:		//	Sprite 4 Y Position		case 0x0A:		//	Sprite 5 X Position		case 0x0B:		//	Sprite 5 Y Position		case 0x0C:		//	Sprite 6 X Position		case 0x0D:		//	Sprite 6 Y Position		case 0x0E:		//	Sprite 7 X Position		case 0x0F:		//	Sprite 7 Y Position		case 0x10:		//	Sprite 0-7 X Position (MSB of X coordinate)			break;*/		case 0x11:		//	VIC Control Register						/*						VIC Control Register							7	Raster Compare: (Bit 8)	See 53266						Ã							6	Extended Color Text Mode 1 = Enable						Ã							5	Bit Map Mode. 1 = Enable									Ã							4	Blank Screen to Border Color: O = Blank				Ã							3	Select 24/25 Row Text Display: 1 = 25 Rows			Ã							2-0	Smooth Scroll to Y Dot-Position (0-7)				¥						*/				val=(val&0x7F) | ((gCurrentRaster&0x100)>>1);			//debug_window_printf("Read VIC 0x11");							break;		case 0x12:		//	Read/Write Raster Value for Compare IRQ			val=gCurrentRaster & 0xFF;			//debug_window_printf("Read VIC 0x12");			break;/*		case 0x13:		//	Light-Pen Latch X Position			break;		case 0x14:		//	Light-Pen Latch Y Position			break;		case 0x15:		//	Sprite Display Enable (1 = Enable)			break;		case 0x16:		//	VIC Control Register			break;		case 0x17:		//	Sprites 0-7 Expand 2x Vertical (Y)			break;		case 0x18:		//	VIC Memory Control Register			break;*/		case 0x19:		//	VIC Interrupt Flag Register (Bit = 1: IRQ Occured)			val=VICReadD019();			break;		case 0x1A:		//	IRQ Mask Register: 1 = Interrupt Enabled			val=VICReadD01A();			break;/*		case 0x1B:		//	Sprite to Background Display Priority: 1 = Sprite			break;		case 0x1C:		//	Sprite 0-7 Multi-Color Mode Select: 1 = MCM			break;		case 0x1D:		//	Sprite 0-7 Expand 2x Horizontal (X)			break;*/		case 0x1E:		//	Sprite to Sprite Collision Detect			val=gSpriteToSpriteCollisions;			gSpriteToSpriteCollisions=0;						break;/*		case 0x1F:		//	Sprite to Background Collision Detect			break;		case 0x20:		//	Border Color			break;		case 0x21:		//	Background Color 0			break;		case 0x22:		//	Background Color 1			break;		case 0x23:		//	Background Color 2			break;		case 0x24:		//	Background Color 3			break;		case 0x25:		//	Sprite Multi-Color Register 0			break;		case 0x26:		//	Sprite Multi-Color Register 1			break;		case 0x27:		//	Sprite 0 Color			break;		case 0x28:		//	Sprite 1 Color			break;		case 0x29:		//	Sprite 2 Color			break;		case 0x2A:		//	Sprite 3 Color			break;		case 0x2B:		//	Sprite 4 Color			break;		case 0x2C:		//	Sprite 5 Color			break;		case 0x2D:		//	Sprite 6 Color			break;		case 0x2E:		//	Sprite 7 Color			break;*//*		default:			break;*/	}		#if	LOCALDEBUG && DEBUG		if (reg!=0x20&& reg!=0x21)		if (gVerbose)			debug_window_printf("VICRead: reg: %X, val: %X",(int)reg,(int)val);	#endif//	gVICReg[reg] = val;	return val;}