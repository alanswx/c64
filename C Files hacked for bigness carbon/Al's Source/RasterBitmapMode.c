#include	"ColorDrawing.h"#include "ExternColorLookupTab.h"#include "drawing.h"#include	"DrawingGlobals.h"void	RasterLine_Bitmap_40CharSLOW(short	rasterline){register	unsigned long				i;register	unsigned long				*dstImagePosition;register	unsigned char				*VideoCharacterByte;register	unsigned char				*screenData;    fprintf(stderr,"RasterLine_Bitmap_40CharSLOW %d\n",rl);////	each char in charrom is eight bytes. There are 40 accross on the screen.// take the rasterline / 8 multiply by 40 to find the character number that we should start on.//	{register	unsigned	long				rasterbasedoffset=gRasterBasedOffset[rasterline];VideoCharacterByte=gVideoCharacterBase+(rasterbasedoffset<<3) + (rasterline&0x07);screenData=gVideoScreenRamBase+ (rasterbasedoffset);}dstImagePosition=(unsigned long *)gTheActiveBitsArray[rasterline];////	draw border here//////	draw characters//for (i=0;i<40;i++)	{	register unsigned	long	four_pixels;	register	unsigned	char	colors;	register	unsigned long	zerocolor;	register	unsigned	long	onecolor;	register	unsigned	long	inverse_pixels;////	grab the two colors from the top and bottom nybbles of the screen ram//// top 		= bits set to 1// bottom 	= bits set to 0////	grab the bitpattern from the charmap..//		colors=*(screenData++);	zerocolor=eightBitTable[(colors&0x0F)];	onecolor=eightBitTable[(colors>>4)];//temporary.//	zerocolor=eightBitTable[0];//	onecolor=eightBitTable[1];	four_pixels=ColorFF[(*VideoCharacterByte) >> 4];	inverse_pixels=~four_pixels;		four_pixels=(onecolor&four_pixels)	| (zerocolor &inverse_pixels);	*(dstImagePosition++)=four_pixels;	four_pixels=ColorFF[((*VideoCharacterByte)&0x0F)];	inverse_pixels=~four_pixels;		four_pixels=(onecolor&four_pixels)	| (zerocolor &inverse_pixels);		*(dstImagePosition++)=four_pixels;	VideoCharacterByte+=8;	}	////	draw border here//}