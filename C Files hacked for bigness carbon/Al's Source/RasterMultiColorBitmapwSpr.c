/*-------------------------------------------------------------------------------*\||	File:	RasterMultiColorBitmapwSpr.c||	Description:||||||	Copyright ï¿½	1994, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include		"ColorDrawing.h"#include 	"Drawing.h"#include		"DrawingGlobals.h"#include		"VICSprites.h"extern	short			gSpriteOnRaster[256];void	RasterLine_MultiColorBitmap_Sprite_40Char(short	rasterline){register	UInt32		i;register	unsigned short		*dstImageSmaller;			unsigned	char		*sprImagePosition;register	unsigned char		*VideoCharacterByte;register	UInt32		rasterbasedoffset=gRasterBasedOffset[rasterline];register	unsigned char		*screenData;register	unsigned char		*curColorLine;//register	UInt32		*cachegandbackcolor=gAndBackColor;           // fprintf(stderr,"RasterLine_MultiColorBitmap_Sprite_40Char %d\n",rasterline);    ////	each char in charrom is eight bytes. There are 40 across on the screen.// take the rasterline / 8 multiply by 40 to find the character number that we should start on.//	VideoCharacterByte=gVideoCharacterBase+(rasterbasedoffset*8) + (rasterline&0x07);curColorLine=gVideoColorBase+rasterbasedoffset;screenData=gVideoScreenRamBase+ (rasterbasedoffset);dstImageSmaller=(unsigned short *)gTheActiveBitsArray[rasterline];sprImagePosition=(unsigned	char	*)dstImageSmaller;////	draw border here//////	draw characters//	for (i=0;i<40;i++)		{		register	unsigned	char		bits=*VideoCharacterByte;			switch (bits>>4)			{			case	0:				*((UInt32 *)dstImageSmaller)=ntohl(gAndBackColor[0]);				dstImageSmaller+=2;			break;			case	1:				*(dstImageSmaller++)=ntohl(*gAndBackColor);				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)>>4)]);			break;			case	2:				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)&0x0F)]);			break;			case	3:				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);			break;					case	4:				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)>>4)]);				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);			break;			case	5:				*((UInt32 *)dstImageSmaller)=ntohl(eightBitTable[((*screenData)>>4)]);				dstImageSmaller+=2;			break;			case	6:				{				register	UInt32	temp=*screenData;					*(dstImageSmaller++)=ntohl(eightBitTable[((temp)>>4)]);				*(dstImageSmaller++)=ntohl(eightBitTable[((temp)&0x0F)]);					}			break;			case	7:				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)>>4)]);				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);			break;					case	8:				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)&0x0F)]);				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);			break;			case	9:				{				register	UInt32	temp=*screenData;					*(dstImageSmaller++)=ntohl(eightBitTable[((temp)&0x0F)]);				*(dstImageSmaller++)=ntohl(eightBitTable[((temp)>>4)]);					}			break;			case	10:				*((UInt32 *)dstImageSmaller)=ntohl(eightBitTable[((*screenData)&0x0F)]);				dstImageSmaller+=2;			break;			case	11:				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)&0x0F)]);				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);			break;					case	12:				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);			break;			case	13:				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)>>4)]);			break;			case	14:				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)&0x0F)]);			break;			case	15:			*((UInt32 *)dstImageSmaller)=ntohl(eightBitTable[*curColorLine]);			dstImageSmaller+=2;			break;								}			switch (bits&0x0F)			{			case	0:				*((UInt32 *)dstImageSmaller)=ntohl(gAndBackColor[0]);				dstImageSmaller+=2;			break;			case	1:				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);				*(dstImageSmaller++)=ntohl(eightBitTable[(*screenData)>>4]);			break;			case	2:				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)&0x0F)]);			break;			case	3:				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);			break;					case	4:				*(dstImageSmaller++)=ntohl(eightBitTable[(*screenData)>>4]);				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);			break;			case	5:				*((UInt32 *)dstImageSmaller)=ntohl(eightBitTable[(*screenData)>>4]);				dstImageSmaller+=2;			break;			case	6:				{				register	UInt32	temp=*screenData;					*(dstImageSmaller++)=ntohl(eightBitTable[((temp)>>4)]);				*(dstImageSmaller++)=ntohl(eightBitTable[((temp)&0x0F)]);					}			break;			case	7:				*(dstImageSmaller++)=ntohl(eightBitTable[(*screenData)>>4]);				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);			break;					case	8:				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)&0x0F)]);				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);			break;			case	9:				{				register	UInt32	temp=*screenData;					*(dstImageSmaller++)=ntohl(eightBitTable[((temp)&0x0F)]);				*(dstImageSmaller++)=ntohl(eightBitTable[((temp)>>4)]);				}			break;			case	10:				*(UInt32 *)dstImageSmaller=ntohl(eightBitTable[((*screenData)&0x0F)]);				dstImageSmaller+=2;			break;			case	11:				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)&0x0F)]);				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);			break;					case	12:				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);				*(dstImageSmaller++)=ntohl(gAndBackColor[0]);			break;			case	13:				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);				*(dstImageSmaller++)=ntohl(eightBitTable[(*screenData)>>4]);			break;			case	14:				*(dstImageSmaller++)=ntohl(eightBitTable[*curColorLine]);				*(dstImageSmaller++)=ntohl(eightBitTable[((*screenData)&0x0F)]);			break;			case	15:				*((UInt32 *)dstImageSmaller)=ntohl(eightBitTable[*curColorLine]);				dstImageSmaller+=2;			break;								}		screenData++;	curColorLine++;	VideoCharacterByte+=8;		}		if (gSpriteOnRaster[rasterline+50])	SpriteDrawOneRaster(rasterline+50,sprImagePosition);////	draw border here//}