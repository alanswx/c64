/*-------------------------------------------------------------------------------*\||	File:	RasterMultiColorBitmapwSpr.c||	Description:||||||	Copyright ©	1994, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include		"ColorDrawing.h"#include 	"Drawing.h"#include		"DrawingGlobals.h"#include		"VICSprites.h"extern	short			gSpriteOnRaster[256];void	RasterLine_MultiColorBitmap_Sprite_40Char(short	rasterline){register	unsigned long		i;register	unsigned short		*dstImageSmaller;			unsigned	char		*sprImagePosition;register	unsigned char		*VideoCharacterByte;register	unsigned	long		rasterbasedoffset=gRasterBasedOffset[rasterline];register	unsigned char		*screenData;register	unsigned char		*curColorLine;register	unsigned long		*cachegandbackcolor=gAndBackColor;////	each char in charrom is eight bytes. There are 40 accross on the screen.// take the rasterline / 8 multiply by 40 to find the character number that we should start on.//	VideoCharacterByte=gVideoCharacterBase+(rasterbasedoffset*8) + (rasterline&0x07);curColorLine=gVideoColorBase+rasterbasedoffset;screenData=gVideoScreenRamBase+ (rasterbasedoffset);dstImageSmaller=(unsigned short *)gTheActiveBitsArray[rasterline];sprImagePosition=(unsigned	char	*)dstImageSmaller;////	draw border here//////	draw characters//	for (i=0;i<40;i++)		{		register	unsigned	char		bits=*VideoCharacterByte;			switch (bits>>4)			{			case	0:				*((unsigned long *)dstImageSmaller)=gAndBackColor[0];				dstImageSmaller+=2;			break;			case	1:				*(dstImageSmaller++)=*gAndBackColor;						*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];			break;			case	2:				*(dstImageSmaller++)=gAndBackColor[0];				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	3:				*(dstImageSmaller++)=gAndBackColor[0];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	4:				*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];				*(dstImageSmaller++)=gAndBackColor[0];			break;			case	5:				*((unsigned long *)dstImageSmaller)=eightBitTable[(*screenData)>>4];				dstImageSmaller+=2;			break;			case	6:				{				register	unsigned	long	temp=*screenData;					*(dstImageSmaller++)=eightBitTable[((temp)>>4)];				*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];					}			break;			case	7:				*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	8:				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];				*(dstImageSmaller++)=gAndBackColor[0];			break;			case	9:				{				register	unsigned	long	temp=*screenData;					*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];				*(dstImageSmaller++)=eightBitTable[((temp)>>4)];					}			break;			case	10:				*((unsigned long *)dstImageSmaller)=eightBitTable[((*screenData)&0x0F)];				dstImageSmaller+=2;			break;			case	11:				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	12:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=gAndBackColor[0];			break;			case	13:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];			break;			case	14:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	15:			*((unsigned long *)dstImageSmaller)=eightBitTable[*curColorLine];			dstImageSmaller+=2;			break;								}			switch (bits&0x0F)			{			case	0:				*((unsigned long *)dstImageSmaller)=gAndBackColor[0];				dstImageSmaller+=2;			break;			case	1:				*(dstImageSmaller++)=gAndBackColor[0];						*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];			break;			case	2:				*(dstImageSmaller++)=gAndBackColor[0];				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	3:				*(dstImageSmaller++)=gAndBackColor[0];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	4:				*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];				*(dstImageSmaller++)=gAndBackColor[0];			break;			case	5:				*((unsigned long *)dstImageSmaller)=eightBitTable[(*screenData)>>4];				dstImageSmaller+=2;			break;			case	6:				{				register	unsigned	long	temp=*screenData;					*(dstImageSmaller++)=eightBitTable[((temp)>>4)];				*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];					}			break;			case	7:				*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	8:				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];						*(dstImageSmaller++)=gAndBackColor[0];			break;			case	9:				{				register	unsigned	long	temp=*screenData;					*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];				*(dstImageSmaller++)=eightBitTable[((temp)>>4)];				}			break;			case	10:				*(unsigned long *)dstImageSmaller=eightBitTable[((*screenData)&0x0F)];				dstImageSmaller+=2;			break;			case	11:				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];				*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	12:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=gAndBackColor[0];			break;			case	13:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];			break;			case	14:				*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	15:				*((unsigned long *)dstImageSmaller)=eightBitTable[*curColorLine];				dstImageSmaller+=2;			break;								}		screenData++;	curColorLine++;	VideoCharacterByte+=8;		}		if (gSpriteOnRaster[rasterline+50])	SpriteDrawOneRaster(rasterline+50,sprImagePosition);////	draw border here//}