/*	The code here came from Apple's "Principia Off-Screen" tech note (March '92 rev)*/#include "GlobalDefs.h"#include "CVOffscreen.h"#define kMaxRowBytes 	0x3FFE 			/* Maximum number of bytes in a row of pixels */#define kDefaultRes 	0x00480000 		/* Default resolution is 72 DPI; Fixed type */#define kITabRes 		4 				/* Inverse-table resolution */OSErr CreateOffScreen(    Rect       *bounds,     /* Bounding rectangle of off-screen */    short      depth,       /* Desired number of bits per pixel in off-screen */    CTabHandle colors,      /* Color table to assign to off-screen */    CGrafPtr   *retPort,    /* Returns a pointer to the new CGrafPort */    GDHandle   *retGDevice) /* Returns a handle to the new GDevice */{    CGrafPtr     newPort;     /* Pointer to the new off-screen CGrafPort */    PixMapHandle newPixMap;   /* Handle to the new off-screen PixMap */    GDHandle     newDevice;   /* Handle to the new off-screen GDevice */    long         qdVersion;   /* Version of QuickDraw currently in use */    GrafPtr      savedPort;   /* Pointer to GrafPort used for save/restore */    SignedByte   savedState;  /* Saved state of color table handle */    short        bytesPerRow; /* Number of bytes per row in the PixMap */    OSErr        error;       /* Returns error code */    /* Initialize a few things before we begin */    newPort = nil;    newPixMap = nil;    newDevice = nil;    error = noErr;    /* Save the color table’s current state and make sure it isn’t purgeable */    if (colors != nil)    {        savedState = HGetState( (Handle)colors );        HNoPurge( (Handle)colors );    }    /* Calculate the number of bytes per row in the off-screen PixMap */    bytesPerRow = ((depth * (bounds->right - bounds->left) + 31) >> 5) << 2;    /* Get the current QuickDraw version */    (void)Gestalt( gestaltQuickdrawVersion, &qdVersion );    /* Make sure depth is indexed or depth is direct and 32-Bit QD installed */    if (depth == 1 || depth == 2 || depth == 4 || depth == 8 ||            ((depth == 16 || depth == 32) && qdVersion >= gestalt32BitQD))    {        /* Maximum number of bytes per row is 16,382; make sure within range */        if (bytesPerRow <= kMaxRowBytes)        {            /* Make sure a color table is provided if the depth is indexed */            if (depth <= 8)            	if (colors == nil)                  /* Indexed depth and clut is NIL; is parameter error */                  error = paramErr;        }        else            /* # of bytes per row is more than 16,382; is parameter error */            error = paramErr;    }    else        /* Pixel depth isn’t valid; is parameter error */        error = paramErr;    /* If sanity checks succeed, then allocate a new CGrafPort */    if (error == noErr)    {        newPort = (CGrafPtr)NewPtr( sizeof (CGrafPort) );        if (newPort != nil)        {            /* Save the current port */            GetPort( &savedPort );            /* Initialize the new CGrafPort and make it the current port */            OpenCPort( newPort );            /* Set portRect, visRgn, and clipRgn to the given bounds rect */            newPort->portRect = *bounds;            RectRgn( newPort->visRgn, bounds );            ClipRect( bounds );            /* Initialize the new PixMap for off-screen drawing */            error = SetUpPixMap( depth, bounds, colors, bytesPerRow,                    newPort->portPixMap );            if (error == noErr)            {                /* Grab the initialized PixMap handle */                newPixMap = newPort->portPixMap;                /* Allocate and initialize a new GDevice */                error = CreateGDevice( newPixMap, &newDevice );            }            /* Restore the saved port */            SetPort( savedPort );        }        else            error = MemError();    }    /* Restore the given state of the color table */    if (colors != nil)        HSetState( (Handle)colors, savedState );    /* One Last Look Around The House Before We Go… */    if (error != noErr)    {        /* Some error occurred; dispose of everything we allocated */        if (newPixMap != nil)        {            DisposCTable( (**newPixMap).pmTable );            DisposPtr( (**newPixMap).baseAddr );        }        if (newDevice != nil)        {            DisposHandle( (Handle)(**newDevice).gdITable );            DisposHandle( (Handle)newDevice );        }        if (newPort != nil)        {            CloseCPort( newPort );            DisposPtr( (Ptr)newPort );        }    }    else    {        /* Everything’s OK; return refs to off-screen CGrafPort and GDevice */        *retPort = newPort;        *retGDevice = newDevice;    }    return error;}OSErr SetUpPixMap(    short        depth,       /* Desired number of bits/pixel in off-screen */    Rect         *bounds,     /* Bounding rectangle of off-screen */    CTabHandle   colors,      /* Color table to assign to off-screen */    short        bytesPerRow, /* Number of bytes per row in the PixMap */    PixMapHandle aPixMap)     /* Handle to the PixMap being initialized */{    CTabHandle newColors;   /* Color table used for the off-screen PixMap */    Ptr        offBaseAddr; /* Pointer to the off-screen pixel image */    OSErr      error;       /* Returns error code */    error = noErr;    newColors = nil;    offBaseAddr = nil;    /* Clone the clut if indexed color; allocate a dummy clut if direct color */    if (depth <= 8)    {        newColors = colors;        error = HandToHand( (Handle *)&newColors );    }    else    {        newColors = (CTabHandle)NewHandle( sizeof (ColorTable) -                sizeof (CSpecArray) );        error = MemError();    }    if (error == noErr)    {        /* Allocate pixel image; long integer multiplication avoids overflow */        offBaseAddr = NewPtrClear( (unsigned long)bytesPerRow * (bounds->bottom -                bounds->top) );        if (offBaseAddr != nil)        {            /* Initialize fields common to indexed and direct PixMaps */            (**aPixMap).baseAddr = offBaseAddr;  /* Point to image */                        (**aPixMap).rowBytes = bytesPerRow | /* MSB set for PixMap */                    0x8000;            (**aPixMap).bounds = *bounds;        /* Use given bounds */            (**aPixMap).pmVersion = 0;           /* No special stuff */            (**aPixMap).packType = 0;            /* Default PICT pack */            (**aPixMap).packSize = 0;            /* Always zero in mem */            (**aPixMap).hRes = kDefaultRes;      /* 72 DPI default res */            (**aPixMap).vRes = kDefaultRes;      /* 72 DPI default res */            (**aPixMap).pixelSize = depth;       /* Set # bits/pixel */            (**aPixMap).planeBytes = 0;          /* Not used */            (**aPixMap).pmReserved = 0;          /* Not used */            /* Initialize fields specific to indexed and direct PixMaps */            if (depth <= 8)            {                /* PixMap is indexed */                (**aPixMap).pixelType = 0;       /* Indicates indexed */                (**aPixMap).cmpCount = 1;        /* Have 1 component */                (**aPixMap).cmpSize = depth;     /* Component size=depth */                (**aPixMap).pmTable = newColors; /* Handle to CLUT */            }            else            {                /* PixMap is direct */                (**aPixMap).pixelType = RGBDirect; /* Indicates direct */                (**aPixMap).cmpCount = 3;          /* Have 3 components */                if (depth == 16)                    (**aPixMap).cmpSize = 5;       /* 5 bits/component */                else                    (**aPixMap).cmpSize = 8;       /* 8 bits/component */                (**newColors).ctSeed = 3 * (**aPixMap).cmpSize;                (**newColors).ctFlags = 0;                (**newColors).ctSize = 0;                (**aPixMap).pmTable = newColors;            }        }        else            error = MemError();    }    else        newColors = nil;    /* If no errors occurred, return a handle to the new off-screen PixMap */    if (error != noErr)    {        if (newColors != nil)            DisposCTable( newColors );    }    /* Return the error code */    return error;}OSErr CreateGDevice(    PixMapHandle basePixMap,  /* Handle to the PixMap to base GDevice on */    GDHandle     *retGDevice) /* Returns a handle to the new GDevice */{    GDHandle   newDevice;  /* Handle to the new GDevice */    ITabHandle embryoITab; /* Handle to the embryonic inverse table */    Rect       deviceRect; /* Rectangle of GDevice */    OSErr      error;      /* Error code */    /* Initialize a few things before we begin */    error = noErr;    newDevice = nil;    embryoITab = nil;    /* Allocate memory for the new GDevice */    newDevice = (GDHandle)NewHandle( sizeof (GDevice) );    if (newDevice != nil)    {        /* Allocate the embryonic inverse table */        embryoITab = (ITabHandle)NewHandleClear( 2 );        if (embryoITab != nil)        {            /* Set rectangle of device to PixMap bounds */            deviceRect = (**basePixMap).bounds;            /* Initialize the new GDevice fields */            (**newDevice).gdRefNum = 0;            /* Only used for screens */            (**newDevice).gdID = 0;                /* Won’t normally use */            if ((**basePixMap).pixelSize <= 8)                (**newDevice).gdType = clutType;   /* Depth≤8; clut device */            else                (**newDevice).gdType = directType; /* Depth>8; direct device */            (**newDevice).gdITable = embryoITab;   /* 2-byte handle for now */            (**newDevice).gdResPref = kITabRes;    /* Normal inv table res */            (**newDevice).gdSearchProc = nil;      /* No color-search proc */            (**newDevice).gdCompProc = nil;        /* No complement proc */            (**newDevice).gdFlags = 0;             /* Will set these later */            (**newDevice).gdPMap = basePixMap;     /* Reference our PixMap */            (**newDevice).gdRefCon = 0;            /* Won’t normally use */            (**newDevice).gdNextGD = nil;          /* Not in GDevice list */            (**newDevice).gdRect = deviceRect;     /* Use PixMap dimensions */            (**newDevice).gdMode = -1;             /* For nonscreens */            (**newDevice).gdCCBytes = 0;           /* Only used for screens */            (**newDevice).gdCCDepth = 0;           /* Only used for screens */            (**newDevice).gdCCXData = 0;           /* Only used for screens */            (**newDevice).gdCCXMask = 0;           /* Only used for screens */            (**newDevice).gdReserved = 0;          /* Currently unused */            /* Set color-device bit if PixMap isn’t black & white */            if ((**basePixMap).pixelSize > 1)                SetDeviceAttribute( newDevice, gdDevType, true );            /* Set bit to indicate that the GDevice has no video driver */            SetDeviceAttribute( newDevice, noDriver, true );            /* Initialize the inverse table */            if ((**basePixMap).pixelSize <= 8)            {                MakeITable( (**basePixMap).pmTable, (**newDevice).gdITable,                        (**newDevice).gdResPref );                error = QDError();            }        }        else            error = MemError();    }    else        error = MemError();    /* Handle any errors along the way */    if (error != noErr)    {        if (embryoITab != nil)            DisposHandle( (Handle)embryoITab );        if (newDevice != nil)            DisposHandle( (Handle)newDevice );    }    else        *retGDevice = newDevice;    /* Return a handle to the new GDevice */    return error;}void DisposeOffScreen(    CGrafPtr doomedPort,    /* Pointer to the CGrafPort to be disposed of */    GDHandle doomedGDevice) /* Handle to the GDevice to be disposed of */{    CGrafPtr currPort;    /* Pointer to the current port */    GDHandle currGDevice; /* Handle to the current GDevice */    /* Check to see whether the doomed CGrafPort is the current port */    GetPort( (GrafPtr *)&currPort );    if (currPort == doomedPort)    {        /* It is; set current port to Window Manager CGrafPort */        GetCWMgrPort( &currPort );        SetPort( (GrafPtr)currPort );    }    /* Check to see whether the doomed GDevice is the current GDevice */    currGDevice = GetGDevice();    if (currGDevice == doomedGDevice)        /* It is; set current GDevice to the main screen’s GDevice */        SetGDevice( GetMainDevice() );    /* Throw everything away */    (**doomedGDevice).gdPMap = nil;    DisposGDevice( doomedGDevice );    DisposPtr( (**doomedPort->portPixMap).baseAddr );    if ((**doomedPort->portPixMap).pmTable != nil)        DisposCTable( (**doomedPort->portPixMap).pmTable );    CloseCPort( doomedPort );    DisposPtr( (Ptr)doomedPort );}