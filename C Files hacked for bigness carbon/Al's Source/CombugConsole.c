/*-------------------------------------------------------------------------------*\||	File:	CombugConsole.c||	Description:||||||	Copyright ï¿½	1994, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include <stdio.h>#include <string.h>#include	<ctype.h>#include	"Accessors.h"#include	"Memory.h"#include "Window.h"#include "Combug.h"#include "CombugWindow.h"#include	"CombugCommands.h"#include	"CommandLineArgsTable.h"#include	"CombugConsole.h"#if 0/*	external globals	*/extern	CombugState			gCombugState;				//Combug.cextern	unsigned	long		gCombugScrollValue;		//Combug.cextern	unsigned	long		gCombugTotalScrollBackLines;extern ReadHandler			*gMemRead;							//	Memory.cextern WriteHandler			*gMemWrite;							//	Memory.cextern unsigned long			gACCRegister;						//	CPUState.cextern unsigned long			gINXRegister;						//	CPUState.cextern unsigned long			gINYRegister;						//	CPUState.cextern unsigned long			gSTACKRegister;					//	CPUState.cextern unsigned long			gPCRegister;						//	CPUState.cextern unsigned long			gSRRegister;						//	CPUState.cextern Ptr						gCombugScrollBackBuffer;extern	WindowPtr			theMonitorWindow;/*	local globals	*/char					gCommandLineHistory[kCommandLineBufSize]={0};char					gCommandLineBuffer[kCommandLineBufSize];unsigned	short		gPosInCLBuffer=0;unsigned	short		gCLInsertionPoint=0;unsigned	short		gDefaultAddress=0;Boolean				gUsingHistory;void	CombugWindowKeyProc	(WindowPtr window,long refcon,char c,unsigned char k,long modifiers){	if (!gCombugState.halted || gCombugState.gto)		return;	CombugDrawInsertionPoint(TRUE);	switch (c)		{		case	0x1E:	//Up Arrow			CombugMoveScrollBackUp();		break;		case	0x1F:	//Down Arrow			CombugMoveScrollBackDown();		break;		case	0x1C:	//Left Arrow			if (gCLInsertionPoint)				gCLInsertionPoint--;						break;		case	0x1D:	//Right Arrow			if (gCLInsertionPoint < (gPosInCLBuffer))				gCLInsertionPoint++;		break;		case	0x0D:	//Return			CombugEntryParseCommandLine();			gCommandLineBuffer[0]=0x00;			gPosInCLBuffer=0;			CombugClearCommandLine();			gCLInsertionPoint=0;			break;		case	0x08:	//Delete						if (gCLInsertionPoint < gPosInCLBuffer && gCLInsertionPoint)				{                    memcpy(&gCommandLineBuffer[gCLInsertionPoint-1],&gCommandLineBuffer[gCLInsertionPoint],gPosInCLBuffer-gCLInsertionPoint);//				BlockMoveData(&gCommandLineBuffer[gCLInsertionPoint],&gCommandLineBuffer[gCLInsertionPoint-1],gPosInCLBuffer-gCLInsertionPoint);					gCommandLineBuffer[gPosInCLBuffer]=0x00;		//keep NULL terminated					gCLInsertionPoint--;					gPosInCLBuffer--;					gCommandLineBuffer[gPosInCLBuffer]=0x00;		//keep NULL terminated					CombugClearCommandLine();									}				else if (gCLInsertionPoint)				{					gPosInCLBuffer--;					gCLInsertionPoint--;					gCommandLineBuffer[gPosInCLBuffer]=0x00;		//keep NULL terminated					CombugClearCommandLine();									}			break;		default:			if (gPosInCLBuffer < kCommandLineBufSize)			{				if (gCLInsertionPoint < gPosInCLBuffer)				{                    memcpy(&gCommandLineBuffer[gCLInsertionPoint+1],&gCommandLineBuffer[gCLInsertionPoint],gPosInCLBuffer-gCLInsertionPoint);                  //  BlockMoveData(&gCommandLineBuffer[gCLInsertionPoint],&gCommandLineBuffer[gCLInsertionPoint+1],gPosInCLBuffer-gCLInsertionPoint);						gCommandLineBuffer[gCLInsertionPoint]=c;						gPosInCLBuffer++;						gCLInsertionPoint++;						gCommandLineBuffer[gPosInCLBuffer]=0x00;		//keep NULL terminated										}				else				{					gCommandLineBuffer[gPosInCLBuffer++]=c;		//add character to buffer					gCommandLineBuffer[gPosInCLBuffer]=0x00;		//keep NULL terminated					gCLInsertionPoint++;				}			}		break;		}	CombugDrawCommandLine(gCommandLineBuffer);	CombugDrawInsertionPoint(TRUE);//	DrawCombugWindow();}void	ForceUppercase(char	*string){	while (*string)		*(string++)= toupper(*string);}void	FindNextChar(char	**next_char){	while (isspace(**next_char)) ++(*next_char);	if (!(**next_char))		*next_char=NULL;}Boolean	IsHexWord(char	*word){		if (!strlen(word))		return false;	while (*word)		if (!isxdigit(*word++))			return false;	return true;}Boolean	IsDecimalWord(char	*word){	if (!strlen(word))		return false;	if (*word)		if (*word++!='#')			return false;		while (*word)		if (!isdigit(*word++))			return false;		return true;}unsigned	long	HexOrDecOrPCStr2Num(char	*word){	unsigned	long	val=0;		if (!strcmp("PC",word) || !strcmp("pc",word))	{		val=gPCRegister;	}	else if	(!strcmp("ra",word) || !strcmp("RA",word))	{		val=gACCRegister;	}	else if	(!strcmp("rx",word) || !strcmp("RX",word))	{		val=gINXRegister;	}		else if	(!strcmp("ry",word) || !strcmp("RY",word))	{		val=gINYRegister;	}		else if	(!strcmp("sr",word) || !strcmp("SR",word))	{			val=gSRRegister;	}		else if  (IsHexWord(word))	{		sscanf(word,"%lX",&val);			}	else if (IsDecimalWord(word))	{		sscanf(word,"#%ld",&val);	}		return val;}#endifchar	dec2hex[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};void	DecToHexStr(char *destStr, unsigned short	hexnum){	*destStr++=dec2hex[(hexnum>>12)];	*destStr++=dec2hex[(hexnum>>8)&0x0F];	*destStr++=dec2hex[(hexnum>>4)&0x0F];	*destStr++=dec2hex[(hexnum)&0x0F];	*destStr=0;}#if 0void	CombugEntryParseCommandLine(void){	char				CL_name[kCommandLineBufSize];	//needs to be the same size as the max characters can be typed	char				*next_arg=NULL;	unsigned	long	result;	short				i;	Boolean			fn_found=false;		//	//	Create History	//	if (!gPosInCLBuffer)		{		strcpy(gCommandLineBuffer,gCommandLineHistory);		gUsingHistory=TRUE;		}	else		gUsingHistory=FALSE;	strcpy(gCommandLineHistory,gCommandLineBuffer);		//	//	//		if (sscanf(gCommandLineBuffer,"%s",CL_name)!=0)	{						next_arg=gCommandLineBuffer+strlen(CL_name);		FindNextChar(&next_arg);		ForceUppercase(CL_name);		for (i=0;i<sizeof(CLLokkupTable)/sizeof(CLLookupEntry);i++)			{						if (!strcmp(CLLokkupTable[i].name,CL_name))				{				result=CLLokkupTable[i].function(next_arg);				fn_found=true;				break;				}			}		if (!fn_found)		{			if (IsHexWord(CL_name))			{				CL_HexWord(gCommandLineBuffer);				}				else if (IsDecimalWord(CL_name))			{				CL_DecWord(gCommandLineBuffer);					}		}					}}unsigned	long	CL_Beep(char	*CommandLine){SysBeep(0);return 0;}////	HexWord:	just a number was typed..//unsigned	long	CL_HexWord(char	*fullCommandLine){	unsigned	long	hexword;	char	asciiconversion1,asciiconversion2;		if(!gUsingHistory)	{		strcpy(gCommandLineHistory," ");		sscanf(fullCommandLine,"%lX",&hexword);			if (isprint(((hexword>>8)&0x00FF)))			asciiconversion1=((hexword>>8)&0x00FF);		else			asciiconversion1=' ';		if (isprint((hexword&0x00FF)))			asciiconversion2=(hexword&0x00FF);		else			asciiconversion2=' ';			CombugScrollPrintf("%X = $%04X   #%ld  '%c%c'",hexword,hexword,hexword,asciiconversion1,asciiconversion2);	}	return 0;}////	DecWord:	just a number was typed..//unsigned	long	CL_DecWord(char	*fullCommandLine){	unsigned	long	decword;	char	asciiconversion1,asciiconversion2;			if(!gUsingHistory)	{		strcpy(gCommandLineHistory," ");		sscanf(fullCommandLine,"#%ld",&decword);			if (isprint(((decword>>8)&0x00FF)))			asciiconversion1=((decword>>8)&0x00FF);		else			asciiconversion1=' ';		if (isprint((decword&0x00FF)))			asciiconversion2=(decword&0x00FF);		else			asciiconversion2=' ';			CombugScrollPrintf("#%d = $%04X   #%ld  '%c%c'",decword,decword,decword,asciiconversion1,asciiconversion2);	}	return 0;}////	IL:	[addr] [n]//unsigned	long	CL_IL(char	*CommandLine){	unsigned long	address;	unsigned	long	linesTodis;	char		addrstr[256];	char		linestr[256];	unsigned short	len;	unsigned	short	base;	unsigned	short	parameters;	Boolean	dontdis=false;	char	buf[256];			strcpy(gCommandLineHistory,"il");	parameters=sscanf(CommandLine,"%lx %lx",&address,&linesTodis);		sscanf(CommandLine,"%s %s",&addrstr,&linestr);	address=HexOrDecOrPCStr2Num(addrstr);	linesTodis=HexOrDecOrPCStr2Num(linestr);	if (parameters==0)		address=gDefaultAddress;	if (!gUsingHistory)	{		if (parameters==0)			address=gPCRegister;		CombugScrollPrintf("Dissasembling from %04X",address);		base = FindCombugSymbol(buf,address);		CombugScrollPrintf("%s",buf);		dontdis=true;	}		if (parameters< 2)		linesTodis=8;						while (linesTodis--)		{		base = FindCombugSymbol(buf,address);		if (!dontdis)		{			dontdis=false;			if (base==address)				CombugScrollPrintf("%s",buf);		}	//gPCRegister		len = DisasmOneOpcode(buf,(unsigned short)address);		CombugScrollPrintf("%s",buf);		address=gDefaultAddress=address+len;		}	return 0;}////	G:	g//unsigned	long	CL_G(char	*CommandLine){	gCombugState.halted = 0;	SelectWindow((WindowPtr)theMonitorWindow);return 0;}////	STEP:	s [n]//unsigned	long	CL_Step(char	*CommandLine){long	numSteps=1;char	stepstr[256];if (CommandLine)		{	sscanf(CommandLine,"%s",stepstr);	numSteps=HexOrDecOrPCStr2Num(stepstr);	CombugScrollPrintf("numsteps=%d, stepstr=%s",numSteps,stepstr);	}gCombugState.step = numSteps;return 0;}unsigned	long	CL_Goto(char	*CommandLine){	unsigned long	address;	char	addressstr[256];	strcpy(gCommandLineHistory," ");/*	sscanf(CommandLine,"%s",addressstr);	//fucking hack because mtrwks barfs	if (strlen(addressstr) && !gUsingHistory)		{		sscanf(CommandLine,"%s",addressstr);		address=HexOrDecOrPCStr2Num(addressstr);		}	else		{		CombugScrollPrintf("This command requires an address");		return 0;		}*/	if (sscanf(CommandLine,"%X",&address)!=1)		{		CombugScrollPrintf("This command requires an address");		return 0;		}	//	address=HexOrDecOrPCStr2Num(addressstr);	gCombugState.step=1;	gCombugState.gtoValue=address;	gCombugState.gto=1;	SelectWindow((WindowPtr)theMonitorWindow);		//gTraceMode = 0;		return 0;}//	DB:	[addr]//unsigned	long	CL_DB(char	*CommandLine){	unsigned long	address;	char	addressstr[256];	unsigned long	val;	char	asciiconversion=' ';		strcpy(gCommandLineHistory,"db");	sscanf(CommandLine,"%s",addressstr);	//fucking hack because mtrwks barfs	if (strlen(addressstr) && !gUsingHistory)		{		sscanf(CommandLine,"%s",addressstr);		address=HexOrDecOrPCStr2Num(addressstr);		}	else		address=gDefaultAddress;	/*	if (sscanf(CommandLine,"%s",addressstr)!=1)		address=gDefaultAddress;	else		address=HexOrDecOrPCStr2Num(addressstr);*/	val=MEMREADBYTE(address);	if (isprint((val&0x00FF)))		asciiconversion=(val&0x00FF);	CombugScrollPrintf("Byte At %04X = $%02X  '%c'",address,val,asciiconversion);	gDefaultAddress=address+1;	return 0;}//	DW:	[addr]//unsigned	long	CL_DW(char	*CommandLine){	unsigned long	address;	char	addressstr[256];	unsigned long	val;	char	asciiconversion1=' ',asciiconversion2=' ';		strcpy(gCommandLineHistory,"dw");		sscanf(CommandLine,"%s",addressstr);	//fucking hack because mtrwks barfs	if (strlen(addressstr) && !gUsingHistory)		{		sscanf(CommandLine,"%s",addressstr);		address=HexOrDecOrPCStr2Num(addressstr);		}	else		address=gDefaultAddress;/*	if (sscanf(CommandLine,"%s",addressstr)!=1)		address=gDefaultAddress;	else		address=HexOrDecOrPCStr2Num(addressstr);*/	val=MEMREADBYTE(address)<<8;	val|=MEMREADBYTE(address+1);	if (isprint(((val>>8)&0x00FF)))		asciiconversion1=((val>>8)&0x00FF);	if (isprint((val&0x00FF)))		asciiconversion2=(val&0x00FF);			CombugScrollPrintf("Word At %04X = $%04X   '%c%c'",address,val,asciiconversion1,asciiconversion2);	gDefaultAddress=address+2;	return 0;}//	DM:	[addr]//unsigned	long	CL_DM(char	*CommandLine){	unsigned long	address;	char	addressstr[256];	unsigned short	runningaddress;	unsigned long	val[8];	char	asciiconversion[16];	short	i,j;		strcpy(gCommandLineHistory,"dm");	sscanf(CommandLine,"%s",addressstr);	//fucking hack because mtrwks barfs	if (strlen(addressstr) && !gUsingHistory)		{		sscanf(CommandLine,"%s",addressstr);		address=HexOrDecOrPCStr2Num(addressstr);		CombugScrollPrintf("Displaying memory from %04X",address);		}	else		address=gDefaultAddress;			//	CombugScrollPrintf("Displaying memory from %4X",address);	runningaddress=address;	for (i=0,j=0;i<8;i++,j+=2)		{		val[i] =	MEMREADBYTE(runningaddress++)<<8;		val[i]|=	MEMREADBYTE(runningaddress++);		if (isprint(((val[i]>>8)&0x00FF)))			asciiconversion[j]=((val[i]>>8)&0x00FF);		else			asciiconversion[j]=' ';		if (isprint((val[i]&0x00FF)))			asciiconversion[j+1]=(val[i]&0x00FF);		else			asciiconversion[j+1]=' ';		}	CombugScrollPrintf("%04X  %04X %04X %04X %04X %04X %04X %04X %04X '%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c'",address,		val[0],val[1],val[2],val[3],val[4],val[5],val[6],val[7],		asciiconversion[0],asciiconversion[1],asciiconversion[2],asciiconversion[3],asciiconversion[4],asciiconversion[5],asciiconversion[6],asciiconversion[7],		asciiconversion[8],asciiconversion[9],asciiconversion[10],asciiconversion[11],asciiconversion[12],asciiconversion[13],asciiconversion[14],asciiconversion[15]);	gDefaultAddress=address+0x10;	return	0;}//	SB:	addr	value//unsigned	long	CL_SB(char	*CommandLine){	unsigned long	address;	unsigned long	val;	if (sscanf(CommandLine,"%lx %lx",&address,&val)!=2)	{		CombugScrollPrintf("Value expected");		//		//	setup dm as the next command if user hits return. Stuff proper address as well		//		sprintf(gCommandLineHistory,"dm");		return 0;	}	//	//	setup dm as the next command if user hits return. Stuff proper address as well	//	gDefaultAddress=address;	sprintf(gCommandLineHistory,"dm");	MEMWRITEBYTE(address,val);	CombugScrollPrintf("Memory Set Starting At %04X",address);	return 0;}//	SW:	addr	value//unsigned	long	CL_SW(char	*CommandLine){	unsigned long	address;	unsigned long	val;	if (sscanf(CommandLine,"%lx %lx",&address,&val)!=2)	{		CombugScrollPrintf("Value expected");		//		//	setup dm as the next command if user hits return. Stuff proper address as well		//		sprintf(gCommandLineHistory,"dm");		return 0;	}	//	//	setup dm as the next command if user hits return. Stuff proper address as well	//	gDefaultAddress=address;	sprintf(gCommandLineHistory,"dm");		MEMWRITEBYTE(address,(val&0x00FF));	MEMWRITEBYTE(address+1,(val>>8));	CombugScrollPrintf("Memory Set Starting At %04X",address);	return 0;}unsigned	long	CL_Help(char	*CommandLine){CombugScrollPrintf("Help:  Not Yet!");return 0;}unsigned	long	CL_BR(char	*CommandLine){SysBeep(0);return 0;}//	//	DV://	Display Combug Versionunsigned	long	CL_Version(char	*CommandLine){CombugScrollPrintf("CombugVersion 1.0");return 0;}////	SX: [ON | OFF]//unsigned	long	CL_SX(char	*CommandLine){	gCombugState.symbols = !gCombugState.symbols;	if (gCombugState.symbols)		CombugScrollPrintf("Symbols enabled");	else		CombugScrollPrintf("Symbols disabled");	DrawCombugWindow();return 0;}////	SC//unsigned	long	CL_SC(char	*CommandLine){unsigned long	myStack;unsigned long	curStack;unsigned	short	stackword;		CombugScrollPrintf("Return addresses on the stack");		CombugScrollPrintf("SA  Caller   Symbol");		curStack=myStack=gSTACKRegister+1+0x100;		curStack=0x1FE;		//		while (curStack < 0x1FF )		while (curStack > (myStack-1) )			{			unsigned	short	opcode;						stackword=MEMREADWORD(curStack);			stackword-=2;	//find the opcode that is two before stack address						opcode=MEMREADBYTE(stackword);			if (opcode==0x20) //check for a JSR instruction				{				char	symbol[256];				unsigned	short	base;								base=FindCombugSymbol(symbol, stackword);							CombugScrollPrintf("%02X  %04X  %s+$%04X",curStack-0x100,stackword,symbol,stackword-base);								}			curStack-=2;			}		CombugScrollPrintf("SA  Caller   Symbol");		curStack=0x1FD;		while (curStack > (myStack-1) )			{			unsigned	short	opcode;						stackword=MEMREADWORD(curStack);			stackword-=2;	//find the opcode that is two before stack address						opcode=MEMREADBYTE(stackword);			if (opcode==0x20) //check for a JSR instruction				{				char	symbol[256];				unsigned	short	base;								base=FindCombugSymbol(symbol, stackword);							CombugScrollPrintf("%02X  %04X  %s+$%04X",curStack-0x100,stackword,symbol,stackword-base);								}			curStack-=2;			}							DrawCombugWindow();return 0;}#endif