/*-------------------------------------------------------------------------------*\||	File:	RasterExtendedColorTextwSpr.c||	Description:||||||	Copyright ©	1994, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include	"ColorDrawing.h"#include "Drawing.h"#include	"DrawingGlobals.h"#include	"VICSprites.h"extern	short				gSpriteOnRaster[256];extern	double			**DColorTables[16];void	RasterLine_DExtendedColorText_Sprite_40Char(short	rasterline){	register	short							i;	register	double						*dstImagePosition;	register	double						*lstImagePosition;				unsigned	char				*sprImagePosition;	register	unsigned char				*screenData;	register	unsigned	char				*curColorLine;	register	unsigned char				*VideoCharacterByte; 			{		register	unsigned	long				rasterbasedoffset=gRasterBasedOffset[rasterline];				VideoCharacterByte=gVideoCharacterBase+(rasterline&0x07); //same as (rasterline %8)				curColorLine	=	gVideoColorBase		+	rasterbasedoffset;		screenData		=	gVideoScreenRamBase	+	rasterbasedoffset;		lstImagePosition=(double *)gTheActiveBitsArray[(rasterline<<1)+1];		dstImagePosition=(double *)gTheActiveBitsArray[rasterline<<1];	}sprImagePosition=(unsigned	char	*)dstImagePosition;////	draw border here//////	draw characters//{register	unsigned	char	*cachegBackColorsUnconverted=gBackColorsUnconverted;register	double			***cacheColorTables=DColorTables;for (i=0;i<8;i++)	{	register	unsigned	char			charlocation;	register	unsigned char			colorVal;	register	unsigned char			curSingleCharMap;	register	double					*MyTable;	//	//	Grab First 2 bits of the screenData[i] and use it to find the background color	//	colorVal=(*(curColorLine++))&0x0F;	charlocation=(*screenData++);	MyTable=cacheColorTables[cachegBackColorsUnconverted[(charlocation&0xC0)>>6]][colorVal];	charlocation&=0x3F;	curSingleCharMap=*(VideoCharacterByte+((charlocation)<<3));	*(dstImagePosition++)=MyTable[(curSingleCharMap) >> 4];	*(dstImagePosition++)=MyTable[(curSingleCharMap&0x0F)];		colorVal=(*(curColorLine++))&0x0F;	charlocation=(*screenData++);	MyTable=cacheColorTables[cachegBackColorsUnconverted[(charlocation&0xC0)>>6]][colorVal];	charlocation&=0x3F;	curSingleCharMap=*(VideoCharacterByte+((charlocation)<<3));	*(dstImagePosition++)=MyTable[(curSingleCharMap) >> 4];	*(dstImagePosition++)=MyTable[(curSingleCharMap&0x0F)];		colorVal=(*(curColorLine++))&0x0F;	charlocation=(*screenData++);	MyTable=cacheColorTables[cachegBackColorsUnconverted[(charlocation&0xC0)>>6]][colorVal];	charlocation&=0x3F;	curSingleCharMap=*(VideoCharacterByte+((charlocation)<<3));	*(dstImagePosition++)=MyTable[(curSingleCharMap) >> 4];	*(dstImagePosition++)=MyTable[(curSingleCharMap&0x0F)];		colorVal=(*(curColorLine++))&0x0F;	charlocation=(*screenData++);	MyTable=cacheColorTables[cachegBackColorsUnconverted[(charlocation&0xC0)>>6]][colorVal];	charlocation&=0x3F;	curSingleCharMap=*(VideoCharacterByte+((charlocation)<<3));	*(dstImagePosition++)=MyTable[(curSingleCharMap) >> 4];	*(dstImagePosition++)=MyTable[(curSingleCharMap&0x0F)];		colorVal=(*(curColorLine++))&0x0F;	charlocation=(*screenData++);	MyTable=cacheColorTables[cachegBackColorsUnconverted[(charlocation&0xC0)>>6]][colorVal];	charlocation&=0x3F;	curSingleCharMap=*(VideoCharacterByte+((charlocation)<<3));	*(dstImagePosition++)=MyTable[(curSingleCharMap) >> 4];	*(dstImagePosition++)=MyTable[(curSingleCharMap&0x0F)];		}}	if (gSpriteOnRaster[rasterline+50])	SpriteDrawOneDRaster(rasterline+50,sprImagePosition);}