/*-------------------------------------------------------------------------------*\||	File:	RasterDMultiColorBitmapwSpr.c||	Description:||||||	Copyright ©	1994, 1995 Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include		"ColorDrawing.h"#include 	"Drawing.h"#include		"DrawingGlobals.h"#include		"VICSprites.h"extern	short			gSpriteOnRaster[256];extern	double			**gDoubleColorTable;void	RasterLine_DMultiColorBitmap_Sprite_40Char(short	rasterline){register	unsigned long		i;register	unsigned long		*dstImageSmaller;register	unsigned long		*lstImageSmaller;			unsigned	char		*sprImagePosition;register	unsigned char		*VideoCharacterByte;register	unsigned	long		rasterbasedoffset=gRasterBasedOffset[rasterline];register	unsigned char		*screenData;register	unsigned char		*curColorLine;register	unsigned long		*cachegandbackcolor=gAndBackColor;////	each char in charrom is eight bytes. There are 40 accross on the screen.// take the rasterline / 8 multiply by 40 to find the character number that we should start on.//	VideoCharacterByte=gVideoCharacterBase+(rasterbasedoffset*8) + (rasterline&0x07);curColorLine=gVideoColorBase+rasterbasedoffset;screenData=gVideoScreenRamBase+ (rasterbasedoffset);dstImageSmaller=(unsigned long *)gTheActiveBitsArray[rasterline<<1];lstImageSmaller=(unsigned long *)gTheActiveBitsArray[(rasterline<<1)+1];sprImagePosition=(unsigned	char	*)dstImageSmaller;////	draw border here//////	draw characters//	for (i=0;i<40;i++)		{		register	unsigned	char		bits=*VideoCharacterByte;			switch (bits>>4)			{			case	0:				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];											break;			case	1:				*(lstImageSmaller++)=*(dstImageSmaller++)=*gAndBackColor;						*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];			break;			case	2:				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	3:				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	4:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];			break;			case	5:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];			break;			case	6:				{				register	unsigned	long	temp=*screenData;					*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((temp)>>4)];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];					}			break;			case	7:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	8:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];			break;			case	9:				{				register	unsigned	long	temp=*screenData;					*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((temp)>>4)];					}			break;			case	10:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	11:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	12:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];			break;			case	13:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)>>4)];			break;			case	14:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	15:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;								}			switch (bits&0x0F)			{			case	0:				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];			break;			case	1:				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];						*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];			break;			case	2:				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	3:				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	4:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];			break;			case	5:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];			break;			case	6:				{				register	unsigned	long	temp=*screenData;					*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((temp)>>4)];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];					}			break;			case	7:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	8:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];						*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];			break;			case	9:				{				register	unsigned	long	temp=*screenData;					*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((temp)>>4)];				}			break;			case	10:				{				register	unsigned	long	temp=*screenData;				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((temp)&0x0F)];				}			break;			case	11:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;					case	12:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(lstImageSmaller++)=*(dstImageSmaller++)=gAndBackColor[0];			break;			case	13:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[(*screenData)>>4];			break;			case	14:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[((*screenData)&0x0F)];			break;			case	15:				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];				*(lstImageSmaller++)=*(dstImageSmaller++)=eightBitTable[*curColorLine];			break;								}		screenData++;	curColorLine++;	VideoCharacterByte+=8;		}		if (gSpriteOnRaster[rasterline+50])	SpriteDrawOneDRaster(rasterline+50,sprImagePosition);////	draw border here//}