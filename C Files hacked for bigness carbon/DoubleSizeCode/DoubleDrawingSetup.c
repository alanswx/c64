/*-------------------------------------------------------------------------------*\||	File:	DoubleDrawingSetup.c||	Description:||||||	Copyright ï¿½	1995, Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include	"DebugWindow.h"#include "ColorTable8Double.h"#include	"DoubleDrawing.h"#if	DEBUGextern	Boolean	gVerbose;#endif////	From ColorDrawing.c//extern	unsigned	long		gPixelDepth;extern	unsigned char		gVICReg[64];////	The border color is already extended to be a long, and be a correct 'Mac' color index////unsigned	long	gBorderColor;////	The array of background colors is already extended and each is a correct 'Mac' color index//extern unsigned	long	gAndBackColor[4];//unsigned	char	gBackColorsUnconverted[4];//// IMPORTANT//double	**DNormal_ColorTable;//unsigned	long	*gRasterBasedOffset;////	This is a table to convert a commodore color into a correct mac color index. This is because//	our color table is not necessarily layed out in the same order as the Commodore's was. There is //	probably a better way of doing this, but I am not that good..////	This table is the 8 bit conversion color table//extern unsigned long eightBitTable[16];double	DEightBitTable[16];double	zeroDouble;////	Thse are the tables used for MultiColor Mode.  The first 8 entries are used for the normal colors//	The other 8 are the multicolor colors/patterns.//double	DMulti_Color0[16];double	DMulti_Color1[16];double	DMulti_Color2[16];double	DMulti_Color3[16];double	DMulti_Color4[16];double	DMulti_Color5[16];double	DMulti_Color6[16];double	DMulti_Color7[16];	double	*DMulti_ColorTable[16] = 	{NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL, DMulti_Color0, DMulti_Color1, DMulti_Color2, DMulti_Color3, DMulti_Color4, DMulti_Color5, DMulti_Color6, DMulti_Color7 };double			**gDoubleColorTable;					//00 00  b0 b0 b0 b0					//00 01	b0 b0 b1 b1					//00 10	b0 b0 b2 b2					//00 11	b0 b0 fg fg					//01 00  b1 b1 b0 b0					//01 01	b1 b1 b1 b1					//01 10	b1 b1 b2 b2					//01 11	b1 b1 fg fg										//10 00  b2 b2 b0 b0					//10 01	b2 b2 b1 b1					//10 10	b2 b2 b2 b2					//10 11	b2 b2 fg fg					//11 00  fg fg b0 b0					//11 01	fg fg b1 b1					//11 10	fg fg b2 b2					//11 11	fg fg bg fg////	These routines build 8 bit and  tables that can be used in multicolor mode.//void	DoubleBuildMultiColorTable8Bit(){	register	short	h,i,k,j;		unsigned	long	oldcolor=gAndBackColor[3];	//	//	Fill in slots 8 through 16 with the correct multicolors	//		for (k=8;k<16;k++)	{		j=0;		gAndBackColor[3]=eightBitTable[k-8];		for (h=0;h<4;h++)			for (i=0;i<4;i++)			{								unsigned long *temp=(unsigned long *)&((DMulti_ColorTable[k])[j++]);				*temp=gAndBackColor[h];				temp++;				*temp=gAndBackColor[i];			}	}	gAndBackColor[3]=oldcolor;	//debug_window_printf("rebuilding 8 bit multicolor table");}void	DoubleBuildColorTable(void){	int		inner,outter,width;	int		forecolor,backcolor;	unsigned	long	k;		unsigned char	byte0,byte1,byte2,byte3;	unsigned char *temp;	unsigned long *tempL;	//	//	Build DColorTable	//		for (backcolor=0;backcolor<16;backcolor++)	{		for (forecolor=0;forecolor<16;forecolor++)		{					for (k=0;k<16;k++)			{				if (k&0x01)	//we have color for byte 0					byte0=forecolor+1;				else					byte0=backcolor+1;				if (k&0x02)	//we have color for byte 0					byte1=forecolor+1;				else					byte1=backcolor+1;				if (k&0x04)	//we have color for byte 0					byte2=forecolor+1;				else					byte2=backcolor+1;				if (k&0x08)	//we have color for byte 0					byte3=forecolor+1;				else					byte3=backcolor+1;									temp=(unsigned char *)&DColorTables[backcolor][forecolor][k];								*temp=byte3;				temp++;				*temp=byte3;				temp++;						*temp=byte2;				temp++;				*temp=byte2;				temp++;						*temp=byte1;				temp++;				*temp=byte1;				temp++;								*temp=byte0;				temp++;				*temp=byte0;		//		DColorTables[backcolor][forecolor][k]=(byte3<<56)&(byte3<<48)&(byte2<<40)&(byte2<<32)&(byte1<<24)&(byte1<<16)&(byte0<<8)&(byte0);			}		}		}	//	//	Build 8 Bit Double Table	//	for (k=0;k<8;k++)	{		tempL=(unsigned long *)&(DEightBitTable[k]);		*tempL++=eightBitTable[k];		*tempL=eightBitTable[k];	}	//	//	Fill in zeroDouble	//		tempL=(unsigned long *)&(zeroDouble);	*tempL++=0;	(*tempL)=0;	}////	This function needs to be called for://			RasterLine_MultiColorText_40Char//			RasterLine_NormalText_40Char//void	DoubleUpdateBackgroundColor_NormalText(void){register	short	i;static	unsigned	long	lastbackcolor=0;//if (lastbackcolor!=gAndBackColor[0])	switch (gPixelDepth)		{		case	8:			DNormal_ColorTable=DColorTables[gVICReg[0x21]];						if (!(gVICReg[0x16]&0x10))				{								gDoubleColorTable=DNormal_ColorTable;				}			else				gDoubleColorTable=DMulti_ColorTable;	//???			for (i=0;i<8;i++)				DMulti_ColorTable[i]=DNormal_ColorTable[i];													break;		default:			Debugger();		break;		}//lastbackcolor=gAndBackColor[0];}