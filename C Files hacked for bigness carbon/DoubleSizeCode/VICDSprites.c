/*-------------------------------------------------------------------------------*\||	File:	VICDSprites.c||	Description:||		||||	Copyright ©	1994, 1995,  Alan Steremberg and Ed Wynne|\*-------------------------------------------------------------------------------*/#include	"DebugWindow.h"#include	"Drawing.h"#include	"DrawingGlobals.h"#include	"VICInterrupts.h"#include	"VICSprites.h"extern	unsigned char	gVICReg[64];extern	unsigned	char	oneSpriteRasterColl[700];extern	unsigned	char 	*gVideoBankRamBase;extern	SpritePtr		spriteRasters[256][8];extern	double			DEightBitTable[16];extern	double			zeroDouble;#if	DEBUGextern	Boolean	gVerbose;#endif#define	COLLISIONS	1void	SpriteDrawOneDRaster(short	rasterline, unsigned char *dstImagePosition){	long				spriteNum;	long				multicolorarr[4];	double			Dmulticolorarr[4];		unsigned	char	collidedSprites=0;		//	//	Build up our multicolor tables, they are filled with longs so we can pull	//	tricks to do pixel replication horizontally.. 	//	Dmulticolorarr[0]=zeroDouble;	Dmulticolorarr[1]=DEightBitTable[gVICReg[0x25]];//	multicolorarr[2]=eightBitTable[gVICReg[0x27+spriteNum]];	//This needs to be filled out based on the sprite..	Dmulticolorarr[3]=DEightBitTable[gVICReg[0x26]];	multicolorarr[0]=0;	multicolorarr[1]=eightBitTable[gVICReg[0x25]];//	multicolorarr[2]=eightBitTable[gVICReg[0x27+spriteNum]];	//This needs to be filled out based on the sprite..	multicolorarr[3]=eightBitTable[gVICReg[0x26]];						{		register	unsigned	long	i;		register	double	*sprlongcollarr=(double *)oneSpriteRasterColl;		for (i=0;i<4;i++)		{			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;			*(sprlongcollarr++)=zeroDouble;		}	}					//SpritePtr	spriteRasters[256][8]={0};	//	//	Plot each sprite in reverse order of precedence	//		{	SpritePtr	*cachespr=spriteRasters[rasterline];		for (spriteNum=7;spriteNum>=0;--spriteNum)		{		register	SpritePtr	cachespriter=cachespr[spriteNum];		//		//	check to see if this sprite exists on this rasterline		//		if (cachespriter)			{			short					left;			short					Dleft;			short					linenum;			unsigned	char		*data;			Boolean				Double;			unsigned long		bkgPriority;			unsigned char		backColor=(unsigned char)gAndBackColor[0];			//			// %%% add sprite over background priority later.. && background collisions						left=cachespriter->bounds.left;			Dleft=cachespriter->bounds.left << 1;	//multiply by two because we are doublesized			bkgPriority=cachespriter->sprOverBkgPriority;////	----------------------	----------------------// |                   	|	|							|//	| --cur raster line 40	|	|	--top	of sprite	|// |     					|	|	--cur raster		|//	| --bottom or sprite 41 |	|	--bottom of sprite|//	|							|	|							|//	|							|	|							|//	----------------------	----------------------////	--top of sprite	FF			if (cachespriter->expandVert)			{				linenum=(rasterline-cachespriter->bounds.top) >> 1;//faster equivalent			}			else			{				linenum=rasterline-cachespriter->bounds.top;			}				data=gVideoBankRamBase+( gVideoScreenRamBase[1016+spriteNum]<<6)+(linenum+linenum+linenum);			if (cachespriter->expandHoriz)				Double=TRUE;			else				Double=FALSE;			if (cachespriter->multiColor)				{				unsigned	long	i;				multicolorarr[2]=eightBitTable[gVICReg[0x27+spriteNum]];	//The rest of the table is filled out once at the top of the function				Dmulticolorarr[2]=DEightBitTable[gVICReg[0x27+spriteNum]];	//The rest of the table is filled out once at the top of the function				//	A sprite is 3 data bytes wide									if (Double)	//check to see if we should double size the sprite//----------------------------------------------////		MultiColor Doubled Sprite Drawing Routines////----------------------------------------------						{						register	double	*sprdataptr;									double	*leftdataptr;									double	*rightdataptr;						register	unsigned	char	*cachesprcollarr=&oneSpriteRasterColl[left];										sprdataptr	=	(double *)&dstImagePosition[Dleft-48];						leftdataptr	=	(double *)dstImagePosition;						rightdataptr=	(double *)dstImagePosition+160;												for (i=0;i<3;i++)							{							register	unsigned	long	data_src=(long)*data++;							register	unsigned	long	temp;												temp=data_src>>6;							if (temp)								{								unsigned	long	k;								if (sprdataptr >= leftdataptr && sprdataptr <= rightdataptr)									if (!bkgPriority)										*sprdataptr=Dmulticolorarr[temp];									else									{										if (backColor==*sprdataptr)											*sprdataptr=Dmulticolorarr[temp];									}										// we need to calculate collision detection for each pixel								// this isn't efficient, there is probably a better way to do it#if	COLLISIONS																for (k=0;k<4;k++)									{									if (*cachesprcollarr)										{										*cachesprcollarr|=1<<spriteNum;										if (sprdataptr >= leftdataptr && sprdataptr <= rightdataptr)											*sprdataptr=Dmulticolorarr[temp];										collidedSprites|=*cachesprcollarr;										}									else												*cachesprcollarr|=1<<spriteNum;									}#endif								}														sprdataptr++;							cachesprcollarr++;														temp=data_src>>4 & 0x03;							if (temp)								{								unsigned	long	k;								if (sprdataptr >= leftdataptr && sprdataptr <= rightdataptr)									if (!bkgPriority)										*sprdataptr=Dmulticolorarr[temp];									else									{										if (backColor==*sprdataptr)											*sprdataptr=Dmulticolorarr[temp];									}									// we need to calculate collision detection for each pixel								// this isn't efficient, there is probably a better way to do it#if	COLLISIONS																for (k=0;k<4;k++)									{									if (*cachesprcollarr)										{										if (sprdataptr >= leftdataptr && sprdataptr <= rightdataptr)											*sprdataptr=Dmulticolorarr[temp];										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										}									else												*cachesprcollarr|=1<<spriteNum;									}#endif								}														sprdataptr++;							cachesprcollarr++;							temp=data_src>>2 & 0x03;													if (temp)								{								unsigned	long	k;								if (sprdataptr >= leftdataptr && sprdataptr <= rightdataptr)									if (!bkgPriority)										*sprdataptr=Dmulticolorarr[temp];									else									{										if (backColor==*sprdataptr)											*sprdataptr=Dmulticolorarr[temp];									}									// we need to calculate collision detection for each pixel								// this isn't efficient, there is probably a better way to do it#if	COLLISIONS																for (k=0;k<4;k++)									{									if (*cachesprcollarr)										{										if (sprdataptr >= leftdataptr && sprdataptr <= rightdataptr)											*sprdataptr=Dmulticolorarr[temp];										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										}									else												*cachesprcollarr|=1<<spriteNum;									}#endif								}														sprdataptr++;							cachesprcollarr++;							temp=data_src&0x03;													if (temp)								{								unsigned	long	k;								if (sprdataptr >= leftdataptr && sprdataptr <= rightdataptr)									if (!bkgPriority)										*sprdataptr=Dmulticolorarr[temp];									else									{										if (backColor==*sprdataptr)											*sprdataptr=Dmulticolorarr[temp];									}									// we need to calculate collision detection for each pixel								// this isn't efficient, there is probably a better way to do it#if	COLLISIONS																for (k=0;k<4;k++)									{									if (*cachesprcollarr)										{										if (sprdataptr >= leftdataptr && sprdataptr <= rightdataptr)											*sprdataptr=Dmulticolorarr[temp];										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										}									else												*cachesprcollarr|=1<<spriteNum;									}#endif								}														sprdataptr++;							cachesprcollarr++;							}						}					else//--------------------------------------------------////		MultiColor Non Doubled Sprite Drawing Routines////--------------------------------------------------						{						register	unsigned	long	*sprshortdataptr;						register	unsigned	char	*cachesprcollarr=&oneSpriteRasterColl[left];									unsigned	long	*leftdataptr;									unsigned	long	*rightdataptr;															sprshortdataptr=(unsigned	long *)	&dstImagePosition[Dleft-48];						leftdataptr=(unsigned long *)			dstImagePosition;						rightdataptr=(unsigned long *)		dstImagePosition+320;						for (i=0;i<3;i++)							{							register	unsigned	long	data_src=(unsigned long)data[i];							register	unsigned	long	temp;//---	1							temp=data_src>>6;							if (temp)								{								if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)									if (!bkgPriority)										*sprshortdataptr=multicolorarr[temp];									else									{										if (backColor==*sprshortdataptr)											*sprshortdataptr=multicolorarr[temp];									}										// we need to calculate collision detection for each pixel									// this isn't efficient, there is probably a better way to do it#if	COLLISIONS									if (*cachesprcollarr)										{										if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)											*sprshortdataptr=multicolorarr[temp];										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										}									else											*cachesprcollarr|=1<<spriteNum;									cachesprcollarr++;									if (*cachesprcollarr)										{										if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)											*sprshortdataptr=multicolorarr[temp];										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										}										else										*cachesprcollarr|=1<<spriteNum;									cachesprcollarr++;									#endif								}							else								{								cachesprcollarr+=2;								}							sprshortdataptr++;//---	2							temp=data_src>>4 & 0x03;							if (temp)								{								if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)									if (!bkgPriority)										*sprshortdataptr=multicolorarr[temp];									else									{										if (backColor==*sprshortdataptr)											*sprshortdataptr=multicolorarr[temp];									}										// we need to calculate collision detection for each pixel									// this isn't efficient, there is probably a better way to do it#if	COLLISIONS									if (*cachesprcollarr)										{										if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)											*sprshortdataptr=multicolorarr[temp];										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										}									else											*cachesprcollarr|=1<<spriteNum;									cachesprcollarr++;									if (*cachesprcollarr)										{										if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)											*sprshortdataptr=multicolorarr[temp];										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										}										else										*cachesprcollarr|=1<<spriteNum;									cachesprcollarr++;#endif								}							else								{								cachesprcollarr+=2;								}							sprshortdataptr++;//---	3							temp=data_src>>2 & 0x03;							if (temp)								{								if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)									if (!bkgPriority)										*sprshortdataptr=multicolorarr[temp];									else									{										if (backColor==*sprshortdataptr)											*sprshortdataptr=multicolorarr[temp];									}											// we need to calculate collision detection for each pixel									// this isn't efficient, there is probably a better way to do it#if	COLLISIONS									if (*cachesprcollarr)										{										if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)											*sprshortdataptr=multicolorarr[temp];										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										}									else											*cachesprcollarr|=1<<spriteNum;									cachesprcollarr++;									if (*cachesprcollarr)										{										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)											*sprshortdataptr=multicolorarr[temp];										}										else										*cachesprcollarr|=1<<spriteNum;									cachesprcollarr++;#endif								}							else								{								cachesprcollarr+=2;								}							sprshortdataptr++;//---	4							temp=data_src&0x03;							if (temp)								{									if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)										if (!bkgPriority)											*sprshortdataptr=multicolorarr[temp];										else										{											if (backColor==*sprshortdataptr)												*sprshortdataptr=multicolorarr[temp];										}										// we need to calculate collision detection for each pixel									// this isn't efficient, there is probably a better way to do it#if	COLLISIONS									if (*cachesprcollarr)										{										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)											*sprshortdataptr=multicolorarr[temp];										}									else											*cachesprcollarr|=1<<spriteNum;									cachesprcollarr++;									if (*cachesprcollarr)										{										*cachesprcollarr|=1<<spriteNum;										collidedSprites|=*cachesprcollarr;										if (sprshortdataptr >= leftdataptr && sprshortdataptr <= rightdataptr)											*sprshortdataptr=multicolorarr[temp];										}										else										*cachesprcollarr|=1<<spriteNum;									cachesprcollarr++;#endif								}							else								{								cachesprcollarr+=2;								}							sprshortdataptr++;							}							}					}			else			{				if (Double)//--------------------------------------------------////		Regular Doubled Sprite Drawing Routines////--------------------------------------------------					{					register	unsigned	long	i;					register	unsigned	short	*sprchardataptr;					register	unsigned	char	*cachesprcollarr=&oneSpriteRasterColl[left];					register	unsigned	short	color=eightBitTable[gVICReg[0x27+spriteNum]];								unsigned	short	*leftdataptr;								unsigned	short	*rightdataptr;					sprchardataptr=(unsigned short *)&dstImagePosition[Dleft-48];					leftdataptr=(unsigned short *)dstImagePosition;					rightdataptr=(unsigned short *)dstImagePosition+320;					for (i=0;i<3;i++)							{											register	unsigned	long	data_src=(long)*data++;						if (data_src&0x80)						{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}							else									*cachesprcollarr|=1<<spriteNum;															cachesprcollarr++;							sprchardataptr++;														if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}								else								*cachesprcollarr|=1<<spriteNum;							cachesprcollarr++;							sprchardataptr++;						}						else							{							cachesprcollarr+=2;							sprchardataptr+=2;							}										if (data_src&0x40)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}							else									*cachesprcollarr|=1<<spriteNum;															cachesprcollarr++;							sprchardataptr++;														if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}								else								*cachesprcollarr|=1<<spriteNum;							cachesprcollarr++;							sprchardataptr++;						}						else							{							sprchardataptr+=2;							cachesprcollarr+=2;							}													if (data_src&0x20)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}							else									*cachesprcollarr|=1<<spriteNum;															cachesprcollarr++;							sprchardataptr++;														if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}								else								*cachesprcollarr|=1<<spriteNum;							cachesprcollarr++;							sprchardataptr++;						}						else							{							sprchardataptr+=2;							cachesprcollarr+=2;							}							if (data_src&0x10)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}							else									*cachesprcollarr|=1<<spriteNum;															cachesprcollarr++;							sprchardataptr++;														if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}								else								*cachesprcollarr|=1<<spriteNum;							cachesprcollarr++;							sprchardataptr++;						}						else							{							sprchardataptr+=2;							cachesprcollarr+=2;							}													if (data_src&0x08)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}							else									*cachesprcollarr|=1<<spriteNum;															cachesprcollarr++;							sprchardataptr++;														if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}								else								*cachesprcollarr|=1<<spriteNum;							cachesprcollarr++;							sprchardataptr++;						}						else							{							sprchardataptr+=2;							cachesprcollarr+=2;							}														if (data_src&0x04)						{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}							else									*cachesprcollarr|=1<<spriteNum;															cachesprcollarr++;							sprchardataptr++;														if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}								else								*cachesprcollarr|=1<<spriteNum;							cachesprcollarr++;							sprchardataptr++;						}						else							{							sprchardataptr+=2;							cachesprcollarr+=2;							}													if (data_src&0x02)						{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}							else									*cachesprcollarr|=1<<spriteNum;															cachesprcollarr++;							sprchardataptr++;														if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}								else								*cachesprcollarr|=1<<spriteNum;							cachesprcollarr++;							sprchardataptr++;						}						else							{							sprchardataptr+=2;							cachesprcollarr+=2;							}							if (data_src&0x01)						{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}							else									*cachesprcollarr|=1<<spriteNum;															cachesprcollarr++;							sprchardataptr++;														if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)							{								if (!bkgPriority)									*(sprchardataptr)=color;								else if (backColor==*sprchardataptr)										*(sprchardataptr)=color;							}							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								collidedSprites|=*cachesprcollarr;								}								else								*cachesprcollarr|=1<<spriteNum;							cachesprcollarr++;							sprchardataptr++;						}						else							{							sprchardataptr+=2;							cachesprcollarr+=2;							}												}				}				else//--------------------------------------------------////		Regular NonDoubled Sprite Drawing Routines////--------------------------------------------------					{					register	unsigned	long	i;					register	unsigned	short	*sprchardataptr;					register	unsigned	char	*cachesprcollarr=&oneSpriteRasterColl[left];					register	unsigned	short	color=eightBitTable[gVICReg[0x27+spriteNum]];								unsigned	short	*leftdataptr;								unsigned	short	*rightdataptr;//Debugger();					sprchardataptr=(unsigned short *)&dstImagePosition[Dleft-48];					leftdataptr=(unsigned short *)dstImagePosition;					rightdataptr=(unsigned short *)dstImagePosition+320;					for (i=0;i<3;i++)							{											register	unsigned	long	data_src=(long)*data++;						if (data_src&0x80)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)								if (!bkgPriority)								{									*(sprchardataptr)=color;								}									else								{									if (backColor==*sprchardataptr)									{										*(sprchardataptr)=color;									}								}#if	COLLISIONS							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								collidedSprites|=*cachesprcollarr;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								}							else									*cachesprcollarr|=1<<spriteNum;#endif						}						cachesprcollarr++;						sprchardataptr++;						if (data_src&0x40)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)								if (!bkgPriority)								{									*(sprchardataptr)=color;								}									else								{									if (backColor==*sprchardataptr)									{										*(sprchardataptr)=color;									}								}#if	COLLISIONS							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								collidedSprites|=*cachesprcollarr;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								}								else								*cachesprcollarr|=1<<spriteNum;#endif						}						sprchardataptr++;						cachesprcollarr++;												if (data_src&0x20)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)								if (!bkgPriority)								{									*(sprchardataptr)=color;								}									else								{									if (backColor==*sprchardataptr)									{										*(sprchardataptr)=color;									}								}#if	COLLISIONS							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								collidedSprites|=*cachesprcollarr;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								}								else								*cachesprcollarr|=1<<spriteNum;#endif						}												sprchardataptr++;						cachesprcollarr++;						if (data_src&0x10)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)								if (!bkgPriority)								{									*(sprchardataptr)=color;								}									else								{									if (backColor==*sprchardataptr)									{										*(sprchardataptr)=color;									}								}#if	COLLISIONS							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								collidedSprites|=*cachesprcollarr;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								}								else								*cachesprcollarr|=1<<spriteNum;#endif						}						sprchardataptr++;						cachesprcollarr++;												if (data_src&0x08)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)								if (!bkgPriority)								{									*(sprchardataptr)=color;								}									else								{									if (backColor==*sprchardataptr)									{										*(sprchardataptr)=color;									}								}#if	COLLISIONS							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								collidedSprites|=*cachesprcollarr;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								}								else								*cachesprcollarr|=1<<spriteNum;#endif						}												sprchardataptr++;						cachesprcollarr++;													if (data_src&0x04)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)								if (!bkgPriority)								{									*(sprchardataptr)=color;								}									else								{									if (backColor==*sprchardataptr)									{										*(sprchardataptr)=color;									}								}#if	COLLISIONS							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								collidedSprites|=*cachesprcollarr;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								}							else									*cachesprcollarr|=1<<spriteNum;#endif						}						sprchardataptr++;						cachesprcollarr++;												if (data_src&0x02)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)								if (!bkgPriority)								{									*(sprchardataptr)=color;								}									else								{									if (backColor==*sprchardataptr)									{										*(sprchardataptr)=color;									}								}#if	COLLISIONS							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								collidedSprites|=*cachesprcollarr;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								}								else								*cachesprcollarr|=1<<spriteNum;#endif						}																				sprchardataptr++;						cachesprcollarr++;						if (data_src&0x01)							{							if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)								if (!bkgPriority)								{									*(sprchardataptr)=color;								}									else								{									if (backColor==*sprchardataptr)									{										*(sprchardataptr)=color;									}								}#if	COLLISIONS							if (*cachesprcollarr)								{								*cachesprcollarr|=1<<spriteNum;								collidedSprites|=*cachesprcollarr;								if (sprchardataptr >= leftdataptr && sprchardataptr <= rightdataptr)									*(sprchardataptr)=color;								}								else								*cachesprcollarr|=1<<spriteNum;#endif						}													sprchardataptr++;						cachesprcollarr++;											}				}			}		}		}	}	////	Pull Interrupt Line If we had a collision//	if (collidedSprites)	SpriteCollideSpriteToSprite(collidedSprites);	}